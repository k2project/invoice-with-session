{"ast":null,"code":"\"use strict\";\n\nconst whatwgURL = require(\"whatwg-url\");\n\nconst HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\n\nconst PopStateEvent = require(\"../generated/PopStateEvent.js\");\n\nconst notImplemented = require(\"../../browser/not-implemented.js\");\n\nconst idlUtils = require(\"../generated/utils.js\"); // https://html.spec.whatwg.org/#session-history\n\n\nclass SessionHistory {\n  constructor(initialEntry, window) {\n    this._window = window;\n    this._windowImpl = idlUtils.implForWrapper(window);\n    this._historyTraversalQueue = new Set();\n    this._entries = [initialEntry];\n    this._currentIndex = 0;\n  }\n\n  _queueHistoryTraversalTask(fn) {\n    const timeoutId = this._window.setTimeout(() => {\n      this._historyTraversalQueue.delete(timeoutId);\n\n      fn();\n    }, 0);\n\n    this._historyTraversalQueue.add(timeoutId);\n  }\n\n  clearHistoryTraversalTasks() {\n    for (const timeoutId of this._historyTraversalQueue) {\n      this._window.clearTimeout(timeoutId);\n    }\n\n    this._historyTraversalQueue.clear();\n  }\n\n  get length() {\n    return this._entries.length;\n  }\n\n  get currentEntry() {\n    return this._entries[this._currentIndex];\n  } // https://html.spec.whatwg.org/#dom-history-pushstate\n\n\n  removeAllEntriesAfterCurrentEntry() {\n    this._entries.splice(this._currentIndex + 1, Infinity);\n  } // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\n\n\n  traverseByDelta(delta) {\n    this._queueHistoryTraversalTask(() => {\n      const newIndex = this._currentIndex + delta;\n\n      if (newIndex < 0 || newIndex >= this.length) {\n        return;\n      }\n\n      const specifiedEntry = this._entries[newIndex]; // Not implemented: unload a document guard\n      // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n      // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n\n      this._queueHistoryTraversalTask(() => {\n        // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\n        // then cancel that attempt to navigate the browsing context.\n        // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\n        // is because these navigations should already count as having \"matured\" because the document is not changing.\n        // this.clearHistoryTraversalTasks();\n        if (specifiedEntry.document !== this.currentEntry.document) {\n          // TODO: unload the active document with the recycle parameter set to false\n          notImplemented(\"Traversing history in a way that would change the window\", this._window);\n        }\n\n        this.traverseHistory(specifiedEntry);\n      });\n    });\n  } // https://html.spec.whatwg.org/#traverse-the-history\n\n\n  traverseHistory(specifiedEntry, flags = {}) {\n    if (!specifiedEntry.document) {\n      // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\n      // to perform an entry update of entry, and abort these steps\n      notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\n    } // Not spec compliant, just minimal. Lots of missing steps.\n\n\n    const nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n    const document = idlUtils.implForWrapper(this._window._document);\n    const {\n      currentEntry\n    } = this; // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\n    // to the value returned by the document.title IDL attribute.\n\n    if (currentEntry.title === undefined) {\n      currentEntry.title = document.title;\n    }\n\n    if (specifiedEntry.document !== currentEntry.document) {\n      // If entry has a different Document object than the current entry, then...\n      notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\n    }\n\n    document._URL = specifiedEntry.url;\n    const hashChanged = specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\n    let oldURL;\n    let newURL;\n\n    if (hashChanged) {\n      oldURL = currentEntry.url;\n      newURL = specifiedEntry.url;\n    }\n\n    if (flags.replacement) {\n      // If the traversal was initiated with replacement enabled, remove the entry immediately before the\n      // specified entry in the session history.\n      this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\n    }\n\n    this.updateCurrentEntry(specifiedEntry);\n    const state = specifiedEntry.stateObject; // TODO structured clone\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n    // but the spec gives them to \"History\" and \"Document\" respecively.\n\n    document._history._state = state;\n    const stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\n    specifiedEntry.document._latestEntry = specifiedEntry;\n\n    const fireEvents = () => this._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\n\n    if (nonBlockingEvents) {\n      this._window.setTimeout(fireEvents, 0);\n    } else {\n      fireEvents();\n    }\n  }\n\n  _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\n    if (stateChanged) {\n      this._windowImpl._dispatch(PopStateEvent.createImpl([\"popstate\", {\n        bubbles: false,\n        state\n      }], {\n        isTrusted: true\n      }));\n    }\n\n    if (hashChanged) {\n      this._windowImpl._dispatch(HashChangeEvent.createImpl([\"hashchange\", {\n        bubbles: false,\n        oldURL: whatwgURL.serializeURL(oldURL),\n        newURL: whatwgURL.serializeURL(newURL)\n      }], {\n        isTrusted: true\n      }));\n    }\n  }\n\n  addEntryAfterCurrentEntry(entry) {\n    this._entries.splice(this._currentIndex + 1, 0, entry);\n  }\n\n  updateCurrentEntry(entry) {\n    this._currentIndex = this._entries.indexOf(entry);\n  }\n\n}\n\nmodule.exports = SessionHistory;","map":{"version":3,"sources":["/Users/krispol/Desktop/invoice/invoice-with-session/client/node_modules/jsdom/lib/jsdom/living/window/SessionHistory.js"],"names":["whatwgURL","require","HashChangeEvent","PopStateEvent","notImplemented","idlUtils","SessionHistory","constructor","initialEntry","window","_window","_windowImpl","implForWrapper","_historyTraversalQueue","Set","_entries","_currentIndex","_queueHistoryTraversalTask","fn","timeoutId","setTimeout","delete","add","clearHistoryTraversalTasks","clearTimeout","clear","length","currentEntry","removeAllEntriesAfterCurrentEntry","splice","Infinity","traverseByDelta","delta","newIndex","specifiedEntry","document","traverseHistory","flags","nonBlockingEvents","Boolean","_document","title","undefined","_URL","url","hashChanged","fragment","oldURL","newURL","replacement","indexOf","updateCurrentEntry","state","stateObject","_history","_state","stateChanged","_latestEntry","fireEvents","_fireEvents","_dispatch","createImpl","bubbles","isTrusted","serializeURL","addEntryAfterCurrentEntry","entry","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nconst whatwgURL = require(\"whatwg-url\");\nconst HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\nconst PopStateEvent = require(\"../generated/PopStateEvent.js\");\nconst notImplemented = require(\"../../browser/not-implemented.js\");\nconst idlUtils = require(\"../generated/utils.js\");\n\n// https://html.spec.whatwg.org/#session-history\nclass SessionHistory {\n  constructor(initialEntry, window) {\n    this._window = window;\n    this._windowImpl = idlUtils.implForWrapper(window);\n    this._historyTraversalQueue = new Set();\n    this._entries = [initialEntry];\n    this._currentIndex = 0;\n  }\n\n  _queueHistoryTraversalTask(fn) {\n    const timeoutId = this._window.setTimeout(() => {\n      this._historyTraversalQueue.delete(timeoutId);\n      fn();\n    }, 0);\n\n    this._historyTraversalQueue.add(timeoutId);\n  }\n\n  clearHistoryTraversalTasks() {\n    for (const timeoutId of this._historyTraversalQueue) {\n      this._window.clearTimeout(timeoutId);\n    }\n    this._historyTraversalQueue.clear();\n  }\n\n  get length() {\n    return this._entries.length;\n  }\n\n  get currentEntry() {\n    return this._entries[this._currentIndex];\n  }\n\n  // https://html.spec.whatwg.org/#dom-history-pushstate\n  removeAllEntriesAfterCurrentEntry() {\n    this._entries.splice(this._currentIndex + 1, Infinity);\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\n  traverseByDelta(delta) {\n    this._queueHistoryTraversalTask(() => {\n      const newIndex = this._currentIndex + delta;\n      if (newIndex < 0 || newIndex >= this.length) {\n        return;\n      }\n\n      const specifiedEntry = this._entries[newIndex];\n\n      // Not implemented: unload a document guard\n\n      // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n      // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n      this._queueHistoryTraversalTask(() => {\n        // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\n        // then cancel that attempt to navigate the browsing context.\n\n        // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\n        // is because these navigations should already count as having \"matured\" because the document is not changing.\n\n        // this.clearHistoryTraversalTasks();\n\n        if (specifiedEntry.document !== this.currentEntry.document) {\n          // TODO: unload the active document with the recycle parameter set to false\n          notImplemented(\"Traversing history in a way that would change the window\", this._window);\n        }\n        this.traverseHistory(specifiedEntry);\n      });\n    });\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history\n  traverseHistory(specifiedEntry, flags = {}) {\n    if (!specifiedEntry.document) {\n      // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\n      // to perform an entry update of entry, and abort these steps\n      notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\n    }\n    // Not spec compliant, just minimal. Lots of missing steps.\n\n    const nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n\n    const document = idlUtils.implForWrapper(this._window._document);\n\n    const { currentEntry } = this;\n\n    // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\n    // to the value returned by the document.title IDL attribute.\n    if (currentEntry.title === undefined) {\n      currentEntry.title = document.title;\n    }\n\n\n    if (specifiedEntry.document !== currentEntry.document) {\n      // If entry has a different Document object than the current entry, then...\n      notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\n    }\n\n    document._URL = specifiedEntry.url;\n\n    const hashChanged =\n      specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\n    let oldURL;\n    let newURL;\n    if (hashChanged) {\n      oldURL = currentEntry.url;\n      newURL = specifiedEntry.url;\n    }\n\n    if (flags.replacement) {\n      // If the traversal was initiated with replacement enabled, remove the entry immediately before the\n      // specified entry in the session history.\n      this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\n    }\n\n    this.updateCurrentEntry(specifiedEntry);\n\n    const state = specifiedEntry.stateObject; // TODO structured clone\n\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n    // but the spec gives them to \"History\" and \"Document\" respecively.\n    document._history._state = state;\n    const stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\n    specifiedEntry.document._latestEntry = specifiedEntry;\n\n    const fireEvents = () => this._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\n\n    if (nonBlockingEvents) {\n      this._window.setTimeout(fireEvents, 0);\n    } else {\n      fireEvents();\n    }\n  }\n\n  _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\n    if (stateChanged) {\n      this._windowImpl._dispatch(PopStateEvent.createImpl([\n        \"popstate\",\n        {\n          bubbles: false,\n          state\n        }\n      ], {\n        isTrusted: true\n      }));\n    }\n\n    if (hashChanged) {\n      this._windowImpl._dispatch(HashChangeEvent.createImpl([\n        \"hashchange\",\n        {\n          bubbles: false,\n          oldURL: whatwgURL.serializeURL(oldURL),\n          newURL: whatwgURL.serializeURL(newURL)\n        }\n      ], {\n        isTrusted: true\n      }));\n    }\n  }\n\n  addEntryAfterCurrentEntry(entry) {\n    this._entries.splice(this._currentIndex + 1, 0, entry);\n  }\n\n  updateCurrentEntry(entry) {\n    this._currentIndex = this._entries.indexOf(entry);\n  }\n}\nmodule.exports = SessionHistory;\n"]},"metadata":{},"sourceType":"script"}