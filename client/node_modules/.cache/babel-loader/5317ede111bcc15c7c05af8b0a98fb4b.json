{"ast":null,"code":"// freeze Array#slice, just in case of funny business later.\nvar _slice = Array.prototype.slice;\n\nvar getPromise = require('./_promise.js'); // deferred gets its own scope to prevent inadvertent capture in the closure\n\n\nvar deferred = function (options) {\n  var Promise = getPromise();\n  var resolve,\n      reject,\n      p = new Promise(function (_resolve, _reject) {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  var pattern = options && options.pattern;\n  var noError = options && options.noError;\n  var cb = pattern ? function (err) {\n    if (err && !noError) {\n      return reject(err);\n    }\n\n    var result = {},\n        i,\n        offset = noError ? 0 : 1;\n\n    for (i = 0; i < pattern.length; i++) {\n      result[pattern[i]] = arguments[i + offset];\n    }\n\n    resolve(result);\n  } : noError ? resolve : function (err, val) {\n    if (err) {\n      reject(err);\n    } else {\n      resolve(val);\n    }\n  };\n  return {\n    promise: p,\n    callback: cb\n  };\n};\n\nvar promisify = module.exports = function (context, func, mandatoryArgs, options) {\n  if (options && options.callbackIsFirstArg) {\n    // duplicate some code here so we don't have to process this unusual\n    // situation at runtime in the common case.\n    return function (cb) {\n      if (typeof cb === 'function') {\n        return func.apply(context, arguments);\n      }\n\n      var d = deferred(options);\n\n      var a = _slice.call(arguments, 0);\n\n      a.unshift(d.callback);\n      func.apply(context, a);\n      return d.promise;\n    };\n  }\n\n  return function () {\n    var cb = arguments[arguments.length - 1];\n\n    if (typeof cb === 'function') {\n      return func.apply(context, arguments);\n    } // ooh, promises.\n\n\n    var d = deferred(options);\n\n    var a = _slice.call(arguments, 0);\n\n    while (a.length < mandatoryArgs) {\n      a.push(undefined);\n    }\n\n    a.push(d.callback);\n    var retval = func.apply(context, a);\n\n    if (options && options.returnsObject) {\n      // it would be nice to have a better convention here\n      Object.defineProperty(retval, 'promise', {\n        value: d.promise\n      });\n      return retval;\n    }\n\n    return d.promise;\n  };\n};","map":{"version":3,"sources":["/Users/krispol/Desktop/invoice/invoice-with-session/client/node_modules/pn/_promisify.js"],"names":["_slice","Array","prototype","slice","getPromise","require","deferred","options","Promise","resolve","reject","p","_resolve","_reject","pattern","noError","cb","err","result","i","offset","length","arguments","val","promise","callback","promisify","module","exports","context","func","mandatoryArgs","callbackIsFirstArg","apply","d","a","call","unshift","push","undefined","retval","returnsObject","Object","defineProperty","value"],"mappings":"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","sourcesContent":["// freeze Array#slice, just in case of funny business later.\nvar _slice = Array.prototype.slice;\nvar getPromise = require('./_promise.js');\n\n// deferred gets its own scope to prevent inadvertent capture in the closure\nvar deferred = function(options) {\n    var Promise = getPromise();\n    var resolve, reject, p = new Promise(function(_resolve, _reject) {\n        resolve = _resolve; reject = _reject;\n    });\n    var pattern = (options && options.pattern);\n    var noError = (options && options.noError);\n    var cb = pattern ? function(err) {\n        if (err && !noError) { return reject(err); }\n        var result = {}, i, offset = noError ? 0 : 1;\n        for (i = 0; i < pattern.length; i++) {\n            result[pattern[i]] = arguments[i+offset];\n        }\n        resolve(result);\n    } : noError ? resolve : function(err, val) {\n        if (err) { reject(err); } else { resolve(val); }\n    };\n    return { promise: p, callback: cb };\n};\nvar promisify = module.exports = function(context, func, mandatoryArgs, options) {\n    if (options && options.callbackIsFirstArg) {\n        // duplicate some code here so we don't have to process this unusual\n        // situation at runtime in the common case.\n        return function(cb) {\n            if (typeof(cb) === 'function') {\n                return func.apply(context, arguments);\n            }\n            var d = deferred(options);\n            var a = _slice.call(arguments, 0);\n            a.unshift(d.callback);\n            func.apply(context, a);\n            return d.promise;\n        };\n    }\n    return function() {\n        var cb = arguments[arguments.length - 1];\n        if (typeof(cb) === 'function') {\n            return func.apply(context, arguments);\n        }\n        // ooh, promises.\n        var d = deferred(options);\n        var a = _slice.call(arguments, 0);\n        while (a.length < mandatoryArgs) { a.push(undefined); }\n        a.push(d.callback);\n        var retval = func.apply(context, a);\n        if (options && options.returnsObject) {\n            // it would be nice to have a better convention here\n            Object.defineProperty(retval, 'promise', { value: d.promise });\n            return retval;\n        }\n        return d.promise;\n    };\n};\n"]},"metadata":{},"sourceType":"script"}