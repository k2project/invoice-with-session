{"ast":null,"code":"\"use strict\";\n\nconst MIMEType = require(\"whatwg-mimetype\");\n\nconst parseDataURL = require(\"data-urls\");\n\nconst sniffHTMLEncoding = require(\"html-encoding-sniffer\");\n\nconst whatwgEncoding = require(\"whatwg-encoding\");\n\nconst fs = require(\"fs\");\n\nconst request = require(\"request\");\n\nconst {\n  documentBaseURLSerialized\n} = require(\"../living/helpers/document-base-url\");\n\nconst NODE_TYPE = require(\"../living/node-type\");\n/* eslint-disable no-restricted-modules */\n// TODO: stop using the built-in URL in favor of the spec-compliant whatwg-url package\n// This legacy usage is in the process of being purged.\n\n\nconst URL = require(\"url\");\n/* eslint-enable no-restricted-modules */\n\n\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\n\nfunction createResourceLoadHandler(element, resourceUrl, document, loadCallback) {\n  if (loadCallback === undefined) {\n    loadCallback = () => {// do nothing\n    };\n  }\n\n  return (err, data, response) => {\n    const ev = document.createEvent(\"HTMLEvents\");\n\n    if (!err) {\n      try {\n        loadCallback.call(element, data, resourceUrl, response);\n        ev.initEvent(\"load\", false, false);\n      } catch (e) {\n        err = e;\n      }\n    }\n\n    if (err) {\n      if (!err.isAbortError) {\n        ev.initEvent(\"error\", false, false);\n        ev.error = err;\n        element.dispatchEvent(ev);\n        const error = new Error(`Could not load ${element.localName}: \"${resourceUrl}\"`);\n        error.detail = err;\n        error.type = \"resource loading\";\n\n        document._defaultView._virtualConsole.emit(\"jsdomError\", error);\n      }\n    } else {\n      element.dispatchEvent(ev);\n    }\n  };\n}\n\nexports.readFile = function (filePath, {\n  defaultEncoding,\n  detectMetaCharset\n}, callback) {\n  const readableStream = fs.createReadStream(filePath);\n  let data = Buffer.alloc(0);\n  readableStream.on(\"error\", callback);\n  readableStream.on(\"data\", chunk => {\n    data = Buffer.concat([data, chunk]);\n  });\n  readableStream.on(\"end\", () => {\n    // Not passing default encoding means binary\n    if (defaultEncoding) {\n      const encoding = detectMetaCharset ? sniffHTMLEncoding(data, {\n        defaultEncoding\n      }) : whatwgEncoding.getBOMEncoding(data) || defaultEncoding;\n      const decoded = whatwgEncoding.decode(data, encoding);\n      callback(null, decoded, {\n        headers: {\n          \"content-type\": \"text/plain;charset=\" + encoding\n        }\n      });\n    } else {\n      callback(null, data);\n    }\n  });\n  return {\n    abort() {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n\n  };\n};\n\nfunction readDataURL(dataURL, {\n  defaultEncoding,\n  detectMetaCharset\n}, callback) {\n  try {\n    const parsed = parseDataURL(dataURL); // If default encoding does not exist, pass on binary data.\n\n    if (defaultEncoding) {\n      const sniffOptions = {\n        transportLayerEncodingLabel: parsed.mimeType.parameters.get(\"charset\"),\n        defaultEncoding\n      };\n      const encoding = detectMetaCharset ? sniffHTMLEncoding(parsed.body, sniffOptions) : whatwgEncoding.getBOMEncoding(parsed.body) || whatwgEncoding.labelToName(parsed.mimeType.parameters.get(\"charset\")) || defaultEncoding;\n      const decoded = whatwgEncoding.decode(parsed.body, encoding);\n      parsed.mimeType.parameters.set(\"charset\", encoding);\n      callback(null, decoded, {\n        headers: {\n          \"content-type\": parsed.mimeType.toString()\n        }\n      });\n    } else {\n      callback(null, parsed.body, {\n        headers: {\n          \"content-type\": parsed.mimeType.toString()\n        }\n      });\n    }\n  } catch (err) {\n    callback(err, null);\n  }\n\n  return null;\n} // NOTE: request wraps tough-cookie cookie jar\n// (see: https://github.com/request/request/blob/master/lib/cookies.js).\n// Therefore, to pass our cookie jar to the request, we need to create\n// request's wrapper and monkey patch it with our jar.\n\n\nexports.wrapCookieJarForRequest = cookieJar => {\n  const jarWrapper = request.jar();\n  jarWrapper._jar = cookieJar;\n  return jarWrapper;\n};\n\nfunction fetch(urlObj, options, callback) {\n  if (urlObj.protocol === \"data:\") {\n    return readDataURL(urlObj.href, options, callback);\n  } else if (urlObj.hostname) {\n    return exports.download(urlObj, options, callback);\n  }\n\n  const filePath = urlObj.pathname.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, \"$1:/\").replace(/%20/g, \" \");\n  return exports.readFile(filePath, options, callback);\n}\n\nexports.enqueue = function (element, resourceUrl, callback) {\n  const document = element.nodeType === NODE_TYPE.DOCUMENT_NODE ? element : element._ownerDocument;\n\n  if (document._queue) {\n    const loadHandler = createResourceLoadHandler(element, resourceUrl || document.URL, document, callback);\n    return document._queue.push(loadHandler);\n  }\n\n  return () => {// do nothing in queue-less documents\n  };\n};\n\nexports.download = function (url, options, callback) {\n  const requestOptions = {\n    pool: options.pool,\n    agent: options.agent,\n    agentOptions: options.agentOptions,\n    agentClass: options.agentClass,\n    strictSSL: options.strictSSL,\n    gzip: true,\n    jar: exports.wrapCookieJarForRequest(options.cookieJar),\n    encoding: null,\n    headers: {\n      \"User-Agent\": options.userAgent,\n      \"Accept-Language\": \"en\",\n      Accept: options.accept || \"*/*\"\n    }\n  };\n\n  if (options.referrer && !IS_BROWSER) {\n    requestOptions.headers.referer = options.referrer;\n  }\n\n  if (options.proxy) {\n    requestOptions.proxy = options.proxy;\n  }\n\n  Object.assign(requestOptions.headers, options.headers);\n  const {\n    defaultEncoding,\n    detectMetaCharset\n  } = options;\n  const req = request(url, requestOptions, (error, response, bufferData) => {\n    if (!error) {\n      // If default encoding does not exist, pass on binary data.\n      if (defaultEncoding) {\n        const contentType = MIMEType.parse(response.headers[\"content-type\"]) || new MIMEType(\"text/plain\");\n        const sniffOptions = {\n          transportLayerEncodingLabel: contentType.parameters.get(\"charset\"),\n          defaultEncoding\n        };\n        const encoding = detectMetaCharset ? sniffHTMLEncoding(bufferData, sniffOptions) : whatwgEncoding.getBOMEncoding(bufferData) || whatwgEncoding.labelToName(contentType.parameters.get(\"charset\")) || defaultEncoding;\n        const decoded = whatwgEncoding.decode(bufferData, encoding);\n        contentType.parameters.set(\"charset\", encoding);\n        response.headers[\"content-type\"] = contentType.toString();\n        callback(null, decoded, response);\n      } else {\n        callback(null, bufferData, response);\n      }\n    } else {\n      callback(error, null, response);\n    }\n  });\n  return {\n    abort() {\n      req.abort();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n\n  };\n};\n\nexports.load = function (element, urlString, options, callback) {\n  const document = element._ownerDocument;\n  const documentImpl = document.implementation;\n\n  if (!documentImpl._hasFeature(\"FetchExternalResources\", element.tagName.toLowerCase())) {\n    return;\n  }\n\n  if (documentImpl._hasFeature(\"SkipExternalResources\", urlString)) {\n    return;\n  }\n\n  const urlObj = URL.parse(urlString);\n  const enqueued = exports.enqueue(element, urlString, callback);\n  const customLoader = document._customResourceLoader;\n  const requestManager = document._requestManager;\n  const cookieJar = document._cookieJar;\n  options.accept = element._accept;\n  options.cookieJar = cookieJar;\n  options.referrer = document.URL;\n  options.pool = document._pool;\n  options.agentOptions = document._agentOptions;\n  options.strictSSL = document._strictSSL;\n  options.proxy = document._proxy;\n  options.userAgent = document._defaultView.navigator.userAgent;\n  let req = null;\n\n  function wrappedEnqueued() {\n    if (req && requestManager) {\n      requestManager.remove(req);\n    } // do not trigger if the window is closed\n\n\n    if (element._ownerDocument && element._ownerDocument.defaultView.document) {\n      enqueued.apply(this, arguments);\n    }\n  }\n\n  if (typeof customLoader === \"function\") {\n    req = customLoader({\n      element,\n      url: urlObj,\n      cookie: cookieJar.getCookieStringSync(urlObj, {\n        http: true\n      }),\n      baseUrl: documentBaseURLSerialized(document),\n\n      defaultFetch(fetchCallback) {\n        return fetch(urlObj, options, fetchCallback);\n      }\n\n    }, wrappedEnqueued);\n  } else {\n    req = fetch(urlObj, options, wrappedEnqueued);\n  }\n\n  if (req && requestManager) {\n    requestManager.add(req);\n  }\n};","map":{"version":3,"sources":["/Users/krispol/Desktop/invoice/invoice-with-session/client/node_modules/jsdom/lib/jsdom/browser/resource-loader.js"],"names":["MIMEType","require","parseDataURL","sniffHTMLEncoding","whatwgEncoding","fs","request","documentBaseURLSerialized","NODE_TYPE","URL","IS_BROWSER","Object","prototype","toString","call","process","createResourceLoadHandler","element","resourceUrl","document","loadCallback","undefined","err","data","response","ev","createEvent","initEvent","e","isAbortError","error","dispatchEvent","Error","localName","detail","type","_defaultView","_virtualConsole","emit","exports","readFile","filePath","defaultEncoding","detectMetaCharset","callback","readableStream","createReadStream","Buffer","alloc","on","chunk","concat","encoding","getBOMEncoding","decoded","decode","headers","abort","destroy","readDataURL","dataURL","parsed","sniffOptions","transportLayerEncodingLabel","mimeType","parameters","get","body","labelToName","set","wrapCookieJarForRequest","cookieJar","jarWrapper","jar","_jar","fetch","urlObj","options","protocol","href","hostname","download","pathname","replace","enqueue","nodeType","DOCUMENT_NODE","_ownerDocument","_queue","loadHandler","push","url","requestOptions","pool","agent","agentOptions","agentClass","strictSSL","gzip","userAgent","Accept","accept","referrer","referer","proxy","assign","req","bufferData","contentType","parse","load","urlString","documentImpl","implementation","_hasFeature","tagName","toLowerCase","enqueued","customLoader","_customResourceLoader","requestManager","_requestManager","_cookieJar","_accept","_pool","_agentOptions","_strictSSL","_proxy","navigator","wrappedEnqueued","remove","defaultView","apply","arguments","cookie","getCookieStringSync","http","baseUrl","defaultFetch","fetchCallback","add"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst MIMEType = require(\"whatwg-mimetype\");\nconst parseDataURL = require(\"data-urls\");\nconst sniffHTMLEncoding = require(\"html-encoding-sniffer\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst fs = require(\"fs\");\nconst request = require(\"request\");\nconst { documentBaseURLSerialized } = require(\"../living/helpers/document-base-url\");\nconst NODE_TYPE = require(\"../living/node-type\");\n\n/* eslint-disable no-restricted-modules */\n// TODO: stop using the built-in URL in favor of the spec-compliant whatwg-url package\n// This legacy usage is in the process of being purged.\nconst URL = require(\"url\");\n/* eslint-enable no-restricted-modules */\n\nconst IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\n\nfunction createResourceLoadHandler(element, resourceUrl, document, loadCallback) {\n  if (loadCallback === undefined) {\n    loadCallback = () => {\n      // do nothing\n    };\n  }\n  return (err, data, response) => {\n    const ev = document.createEvent(\"HTMLEvents\");\n\n    if (!err) {\n      try {\n        loadCallback.call(element, data, resourceUrl, response);\n        ev.initEvent(\"load\", false, false);\n      } catch (e) {\n        err = e;\n      }\n    }\n\n    if (err) {\n      if (!err.isAbortError) {\n        ev.initEvent(\"error\", false, false);\n        ev.error = err;\n        element.dispatchEvent(ev);\n\n        const error = new Error(`Could not load ${element.localName}: \"${resourceUrl}\"`);\n        error.detail = err;\n        error.type = \"resource loading\";\n\n        document._defaultView._virtualConsole.emit(\"jsdomError\", error);\n      }\n    } else {\n      element.dispatchEvent(ev);\n    }\n  };\n}\n\nexports.readFile = function (filePath, { defaultEncoding, detectMetaCharset }, callback) {\n  const readableStream = fs.createReadStream(filePath);\n\n  let data = Buffer.alloc(0);\n\n  readableStream.on(\"error\", callback);\n\n  readableStream.on(\"data\", chunk => {\n    data = Buffer.concat([data, chunk]);\n  });\n\n  readableStream.on(\"end\", () => {\n    // Not passing default encoding means binary\n    if (defaultEncoding) {\n      const encoding = detectMetaCharset ?\n                       sniffHTMLEncoding(data, { defaultEncoding }) :\n                       whatwgEncoding.getBOMEncoding(data) || defaultEncoding;\n      const decoded = whatwgEncoding.decode(data, encoding);\n      callback(null, decoded, { headers: { \"content-type\": \"text/plain;charset=\" + encoding } });\n    } else {\n      callback(null, data);\n    }\n  });\n\n  return {\n    abort() {\n      readableStream.destroy();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n  };\n};\n\nfunction readDataURL(dataURL, { defaultEncoding, detectMetaCharset }, callback) {\n  try {\n    const parsed = parseDataURL(dataURL);\n    // If default encoding does not exist, pass on binary data.\n    if (defaultEncoding) {\n      const sniffOptions = {\n        transportLayerEncodingLabel: parsed.mimeType.parameters.get(\"charset\"),\n        defaultEncoding\n      };\n\n      const encoding = detectMetaCharset ?\n                       sniffHTMLEncoding(parsed.body, sniffOptions) :\n                       whatwgEncoding.getBOMEncoding(parsed.body) ||\n                        whatwgEncoding.labelToName(parsed.mimeType.parameters.get(\"charset\")) ||\n                        defaultEncoding;\n      const decoded = whatwgEncoding.decode(parsed.body, encoding);\n\n      parsed.mimeType.parameters.set(\"charset\", encoding);\n\n      callback(null, decoded, { headers: { \"content-type\": parsed.mimeType.toString() } });\n    } else {\n      callback(null, parsed.body, { headers: { \"content-type\": parsed.mimeType.toString() } });\n    }\n  } catch (err) {\n    callback(err, null);\n  }\n  return null;\n}\n\n// NOTE: request wraps tough-cookie cookie jar\n// (see: https://github.com/request/request/blob/master/lib/cookies.js).\n// Therefore, to pass our cookie jar to the request, we need to create\n// request's wrapper and monkey patch it with our jar.\nexports.wrapCookieJarForRequest = cookieJar => {\n  const jarWrapper = request.jar();\n  jarWrapper._jar = cookieJar;\n  return jarWrapper;\n};\n\nfunction fetch(urlObj, options, callback) {\n  if (urlObj.protocol === \"data:\") {\n    return readDataURL(urlObj.href, options, callback);\n  } else if (urlObj.hostname) {\n    return exports.download(urlObj, options, callback);\n  }\n  const filePath = urlObj.pathname\n    .replace(/^file:\\/\\//, \"\")\n    .replace(/^\\/([a-z]):\\//i, \"$1:/\")\n    .replace(/%20/g, \" \");\n  return exports.readFile(filePath, options, callback);\n}\n\nexports.enqueue = function (element, resourceUrl, callback) {\n  const document = element.nodeType === NODE_TYPE.DOCUMENT_NODE ? element : element._ownerDocument;\n\n  if (document._queue) {\n    const loadHandler = createResourceLoadHandler(element, resourceUrl || document.URL, document, callback);\n    return document._queue.push(loadHandler);\n  }\n\n  return () => {\n    // do nothing in queue-less documents\n  };\n};\n\nexports.download = function (url, options, callback) {\n  const requestOptions = {\n    pool: options.pool,\n    agent: options.agent,\n    agentOptions: options.agentOptions,\n    agentClass: options.agentClass,\n    strictSSL: options.strictSSL,\n    gzip: true,\n    jar: exports.wrapCookieJarForRequest(options.cookieJar),\n    encoding: null,\n    headers: {\n      \"User-Agent\": options.userAgent,\n      \"Accept-Language\": \"en\",\n      Accept: options.accept || \"*/*\"\n    }\n  };\n  if (options.referrer && !IS_BROWSER) {\n    requestOptions.headers.referer = options.referrer;\n  }\n  if (options.proxy) {\n    requestOptions.proxy = options.proxy;\n  }\n  Object.assign(requestOptions.headers, options.headers);\n\n  const { defaultEncoding, detectMetaCharset } = options;\n\n  const req = request(url, requestOptions, (error, response, bufferData) => {\n    if (!error) {\n      // If default encoding does not exist, pass on binary data.\n      if (defaultEncoding) {\n        const contentType = MIMEType.parse(response.headers[\"content-type\"]) || new MIMEType(\"text/plain\");\n        const sniffOptions = {\n          transportLayerEncodingLabel: contentType.parameters.get(\"charset\"),\n          defaultEncoding\n        };\n\n        const encoding = detectMetaCharset ?\n                         sniffHTMLEncoding(bufferData, sniffOptions) :\n                         whatwgEncoding.getBOMEncoding(bufferData) ||\n                           whatwgEncoding.labelToName(contentType.parameters.get(\"charset\")) ||\n                           defaultEncoding;\n        const decoded = whatwgEncoding.decode(bufferData, encoding);\n\n        contentType.parameters.set(\"charset\", encoding);\n        response.headers[\"content-type\"] = contentType.toString();\n\n        callback(null, decoded, response);\n      } else {\n        callback(null, bufferData, response);\n      }\n    } else {\n      callback(error, null, response);\n    }\n  });\n  return {\n    abort() {\n      req.abort();\n      const error = new Error(\"request canceled by user\");\n      error.isAbortError = true;\n      callback(error);\n    }\n  };\n};\n\nexports.load = function (element, urlString, options, callback) {\n  const document = element._ownerDocument;\n  const documentImpl = document.implementation;\n\n  if (!documentImpl._hasFeature(\"FetchExternalResources\", element.tagName.toLowerCase())) {\n    return;\n  }\n\n  if (documentImpl._hasFeature(\"SkipExternalResources\", urlString)) {\n    return;\n  }\n\n  const urlObj = URL.parse(urlString);\n  const enqueued = exports.enqueue(element, urlString, callback);\n  const customLoader = document._customResourceLoader;\n  const requestManager = document._requestManager;\n  const cookieJar = document._cookieJar;\n\n  options.accept = element._accept;\n  options.cookieJar = cookieJar;\n  options.referrer = document.URL;\n  options.pool = document._pool;\n  options.agentOptions = document._agentOptions;\n  options.strictSSL = document._strictSSL;\n  options.proxy = document._proxy;\n  options.userAgent = document._defaultView.navigator.userAgent;\n\n  let req = null;\n  function wrappedEnqueued() {\n    if (req && requestManager) {\n      requestManager.remove(req);\n    }\n    // do not trigger if the window is closed\n    if (element._ownerDocument && element._ownerDocument.defaultView.document) {\n      enqueued.apply(this, arguments);\n    }\n  }\n  if (typeof customLoader === \"function\") {\n    req = customLoader(\n      {\n        element,\n        url: urlObj,\n        cookie: cookieJar.getCookieStringSync(urlObj, { http: true }),\n        baseUrl: documentBaseURLSerialized(document),\n        defaultFetch(fetchCallback) {\n          return fetch(urlObj, options, fetchCallback);\n        }\n      },\n      wrappedEnqueued\n    );\n  } else {\n    req = fetch(urlObj, options, wrappedEnqueued);\n  }\n  if (req && requestManager) {\n    requestManager.add(req);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}