{"ast":null,"code":"\"use strict\";\n\nconst punycode = require(\"punycode\");\n\nconst regexes = require(\"./lib/regexes.js\");\n\nconst mappingTable = require(\"./lib/mappingTable.json\");\n\nfunction containsNonASCII(str) {\n  return /[^\\x00-\\x7F]/.test(str);\n}\n\nfunction findStatus(val, {\n  useSTD3ASCIIRules\n}) {\n  let start = 0;\n  let end = mappingTable.length - 1;\n\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n    const target = mappingTable[mid];\n\n    if (target[0][0] <= val && target[0][1] >= val) {\n      if (target[1].startsWith(\"disallowed_STD3_\")) {\n        const newStatus = useSTD3ASCIIRules ? \"disallowed\" : target[1].slice(16);\n        return [newStatus, ...target.slice(2)];\n      }\n\n      return target.slice(1);\n    } else if (target[0][0] > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  return null;\n}\n\nfunction mapChars(domainName, {\n  useSTD3ASCIIRules,\n  processingOption\n}) {\n  let hasError = false;\n  let processed = \"\";\n\n  for (const ch of domainName) {\n    const [status, mapping] = findStatus(ch.codePointAt(0), {\n      useSTD3ASCIIRules\n    });\n\n    switch (status) {\n      case \"disallowed\":\n        hasError = true;\n        processed += ch;\n        break;\n\n      case \"ignored\":\n        break;\n\n      case \"mapped\":\n        processed += mapping;\n        break;\n\n      case \"deviation\":\n        if (processingOption === \"transitional\") {\n          processed += mapping;\n        } else {\n          processed += ch;\n        }\n\n        break;\n\n      case \"valid\":\n        processed += ch;\n        break;\n    }\n  }\n\n  return {\n    string: processed,\n    error: hasError\n  };\n}\n\nfunction validateLabel(label, {\n  checkHyphens,\n  checkBidi,\n  checkJoiners,\n  processingOption,\n  useSTD3ASCIIRules\n}) {\n  if (label.normalize(\"NFC\") !== label) {\n    return false;\n  }\n\n  const codePoints = Array.from(label);\n\n  if (checkHyphens) {\n    if (codePoints[2] === \"-\" && codePoints[3] === \"-\" || label.startsWith(\"-\") || label.endsWith(\"-\")) {\n      return false;\n    }\n  }\n\n  if (label.includes(\".\") || codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0])) {\n    return false;\n  }\n\n  for (const ch of codePoints) {\n    const [status] = findStatus(ch.codePointAt(0), {\n      useSTD3ASCIIRules\n    });\n\n    if (processingOption === \"transitional\" && status !== \"valid\" || processingOption === \"nontransitional\" && status !== \"valid\" && status !== \"deviation\") {\n      return false;\n    }\n  } // https://tools.ietf.org/html/rfc5892#appendix-A\n\n\n  if (checkJoiners) {\n    let last = 0;\n\n    for (const [i, ch] of codePoints.entries()) {\n      if (ch === \"\\u200C\" || ch === \"\\u200D\") {\n        if (i > 0) {\n          if (regexes.combiningClassVirama.test(codePoints[i - 1])) {\n            continue;\n          }\n\n          if (ch === \"\\u200C\") {\n            // TODO: make this more efficient\n            const next = codePoints.indexOf(\"\\u200C\", i + 1);\n            const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);\n\n            if (regexes.validZWNJ.test(test.join(\"\"))) {\n              last = i + 1;\n              continue;\n            }\n          }\n        }\n\n        return false;\n      }\n    }\n  } // https://tools.ietf.org/html/rfc5893#section-2\n\n\n  if (checkBidi) {\n    let rtl; // 1\n\n    if (regexes.bidiS1LTR.test(codePoints[0])) {\n      rtl = false;\n    } else if (regexes.bidiS1RTL.test(codePoints[0])) {\n      rtl = true;\n    } else {\n      return false;\n    }\n\n    if (rtl) {\n      // 2-4\n      if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {\n        return false;\n      }\n    } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {\n      // 5-6\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isBidiDomain(labels) {\n  const domain = labels.map(label => {\n    if (label.startsWith(\"xn--\")) {\n      try {\n        return punycode.decode(label.substring(4));\n      } catch (err) {\n        return \"\";\n      }\n    }\n\n    return label;\n  }).join(\".\");\n  return regexes.bidiDomain.test(domain);\n}\n\nfunction processing(domainName, options) {\n  const {\n    processingOption\n  } = options; // 1. Map.\n\n  let {\n    string,\n    error\n  } = mapChars(domainName, options); // 2. Normalize.\n\n  string = string.normalize(\"NFC\"); // 3. Break.\n\n  const labels = string.split(\".\");\n  const isBidi = isBidiDomain(labels); // 4. Convert/Validate.\n\n  for (const [i, origLabel] of labels.entries()) {\n    let label = origLabel;\n    let curProcessing = processingOption;\n\n    if (label.startsWith(\"xn--\")) {\n      try {\n        label = punycode.decode(label.substring(4));\n        labels[i] = label;\n      } catch (err) {\n        error = true;\n        continue;\n      }\n\n      curProcessing = \"nontransitional\";\n    } // No need to validate if we already know there is an error.\n\n\n    if (error) {\n      continue;\n    }\n\n    const validation = validateLabel(label, Object.assign({}, options, {\n      processingOption: curProcessing,\n      checkBidi: options.checkBidi && isBidi\n    }));\n\n    if (!validation) {\n      error = true;\n    }\n  }\n\n  return {\n    string: labels.join(\".\"),\n    error\n  };\n}\n\nfunction toASCII(domainName, {\n  checkHyphens = false,\n  checkBidi = false,\n  checkJoiners = false,\n  useSTD3ASCIIRules = false,\n  processingOption = \"nontransitional\",\n  verifyDNSLength = false\n} = {}) {\n  if (processingOption !== \"transitional\" && processingOption !== \"nontransitional\") {\n    throw new RangeError(\"processingOption must be either transitional or nontransitional\");\n  }\n\n  const result = processing(domainName, {\n    processingOption,\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules\n  });\n  let labels = result.string.split(\".\");\n  labels = labels.map(l => {\n    if (containsNonASCII(l)) {\n      try {\n        return \"xn--\" + punycode.encode(l);\n      } catch (e) {\n        result.error = true;\n      }\n    }\n\n    return l;\n  });\n\n  if (verifyDNSLength) {\n    const total = labels.join(\".\").length;\n\n    if (total > 253 || total === 0) {\n      result.error = true;\n    }\n\n    for (let i = 0; i < labels.length; ++i) {\n      if (labels[i].length > 63 || labels[i].length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n\n  if (result.error) {\n    return null;\n  }\n\n  return labels.join(\".\");\n}\n\nfunction toUnicode(domainName, {\n  checkHyphens = false,\n  checkBidi = false,\n  checkJoiners = false,\n  useSTD3ASCIIRules = false\n} = {}) {\n  const result = processing(domainName, {\n    processingOption: \"nontransitional\",\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules\n  });\n  return {\n    domain: result.string,\n    error: result.error\n  };\n}\n\nmodule.exports = {\n  toASCII,\n  toUnicode\n};","map":{"version":3,"sources":["/Users/krispol/Desktop/invoice/invoice-with-session/client/node_modules/tr46/index.js"],"names":["punycode","require","regexes","mappingTable","containsNonASCII","str","test","findStatus","val","useSTD3ASCIIRules","start","end","length","mid","Math","floor","target","startsWith","newStatus","slice","mapChars","domainName","processingOption","hasError","processed","ch","status","mapping","codePointAt","string","error","validateLabel","label","checkHyphens","checkBidi","checkJoiners","normalize","codePoints","Array","from","endsWith","includes","combiningMarks","last","i","entries","combiningClassVirama","next","indexOf","validZWNJ","join","rtl","bidiS1LTR","bidiS1RTL","bidiS2","bidiS3","bidiS4EN","bidiS4AN","bidiS5","bidiS6","isBidiDomain","labels","domain","map","decode","substring","err","bidiDomain","processing","options","split","isBidi","origLabel","curProcessing","validation","Object","assign","toASCII","verifyDNSLength","RangeError","result","l","encode","e","total","toUnicode","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst punycode = require(\"punycode\");\nconst regexes = require(\"./lib/regexes.js\");\nconst mappingTable = require(\"./lib/mappingTable.json\");\n\nfunction containsNonASCII(str) {\n  return /[^\\x00-\\x7F]/.test(str);\n}\n\nfunction findStatus(val, { useSTD3ASCIIRules }) {\n  let start = 0;\n  let end = mappingTable.length - 1;\n\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n\n    const target = mappingTable[mid];\n    if (target[0][0] <= val && target[0][1] >= val) {\n      if (target[1].startsWith(\"disallowed_STD3_\")) {\n        const newStatus = useSTD3ASCIIRules ? \"disallowed\" : target[1].slice(16);\n        return [newStatus, ...target.slice(2)];\n      }\n      return target.slice(1);\n    } else if (target[0][0] > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  return null;\n}\n\nfunction mapChars(domainName, { useSTD3ASCIIRules, processingOption }) {\n  let hasError = false;\n  let processed = \"\";\n\n  for (const ch of domainName) {\n    const [status, mapping] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });\n\n    switch (status) {\n      case \"disallowed\":\n        hasError = true;\n        processed += ch;\n        break;\n      case \"ignored\":\n        break;\n      case \"mapped\":\n        processed += mapping;\n        break;\n      case \"deviation\":\n        if (processingOption === \"transitional\") {\n          processed += mapping;\n        } else {\n          processed += ch;\n        }\n        break;\n      case \"valid\":\n        processed += ch;\n        break;\n    }\n  }\n\n  return {\n    string: processed,\n    error: hasError\n  };\n}\n\nfunction validateLabel(label, { checkHyphens, checkBidi, checkJoiners, processingOption, useSTD3ASCIIRules }) {\n  if (label.normalize(\"NFC\") !== label) {\n    return false;\n  }\n\n  const codePoints = Array.from(label);\n\n  if (checkHyphens) {\n    if ((codePoints[2] === \"-\" && codePoints[3] === \"-\") ||\n        (label.startsWith(\"-\") || label.endsWith(\"-\"))) {\n      return false;\n    }\n  }\n\n  if (label.includes(\".\") ||\n      (codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0]))) {\n    return false;\n  }\n\n  for (const ch of codePoints) {\n    const [status] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });\n    if ((processingOption === \"transitional\" && status !== \"valid\") ||\n        (processingOption === \"nontransitional\" &&\n         status !== \"valid\" && status !== \"deviation\")) {\n      return false;\n    }\n  }\n\n  // https://tools.ietf.org/html/rfc5892#appendix-A\n  if (checkJoiners) {\n    let last = 0;\n    for (const [i, ch] of codePoints.entries()) {\n      if (ch === \"\\u200C\" || ch === \"\\u200D\") {\n        if (i > 0) {\n          if (regexes.combiningClassVirama.test(codePoints[i - 1])) {\n            continue;\n          }\n          if (ch === \"\\u200C\") {\n            // TODO: make this more efficient\n            const next = codePoints.indexOf(\"\\u200C\", i + 1);\n            const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);\n            if (regexes.validZWNJ.test(test.join(\"\"))) {\n              last = i + 1;\n              continue;\n            }\n          }\n        }\n        return false;\n      }\n    }\n  }\n\n  // https://tools.ietf.org/html/rfc5893#section-2\n  if (checkBidi) {\n    let rtl;\n\n    // 1\n    if (regexes.bidiS1LTR.test(codePoints[0])) {\n      rtl = false;\n    } else if (regexes.bidiS1RTL.test(codePoints[0])) {\n      rtl = true;\n    } else {\n      return false;\n    }\n\n    if (rtl) {\n      // 2-4\n      if (!regexes.bidiS2.test(label) ||\n          !regexes.bidiS3.test(label) ||\n          (regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label))) {\n        return false;\n      }\n    } else if (!regexes.bidiS5.test(label) ||\n               !regexes.bidiS6.test(label)) { // 5-6\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isBidiDomain(labels) {\n  const domain = labels.map(label => {\n    if (label.startsWith(\"xn--\")) {\n      try {\n        return punycode.decode(label.substring(4));\n      } catch (err) {\n        return \"\";\n      }\n    }\n    return label;\n  }).join(\".\");\n  return regexes.bidiDomain.test(domain);\n}\n\nfunction processing(domainName, options) {\n  const { processingOption } = options;\n\n  // 1. Map.\n  let { string, error } = mapChars(domainName, options);\n\n  // 2. Normalize.\n  string = string.normalize(\"NFC\");\n\n  // 3. Break.\n  const labels = string.split(\".\");\n  const isBidi = isBidiDomain(labels);\n\n  // 4. Convert/Validate.\n  for (const [i, origLabel] of labels.entries()) {\n    let label = origLabel;\n    let curProcessing = processingOption;\n    if (label.startsWith(\"xn--\")) {\n      try {\n        label = punycode.decode(label.substring(4));\n        labels[i] = label;\n      } catch (err) {\n        error = true;\n        continue;\n      }\n      curProcessing = \"nontransitional\";\n    }\n\n    // No need to validate if we already know there is an error.\n    if (error) {\n      continue;\n    }\n    const validation = validateLabel(label, Object.assign({}, options, {\n      processingOption: curProcessing,\n      checkBidi: options.checkBidi && isBidi\n    }));\n    if (!validation) {\n      error = true;\n    }\n  }\n\n  return {\n    string: labels.join(\".\"),\n    error\n  };\n}\n\nfunction toASCII(domainName, {\n  checkHyphens = false,\n  checkBidi = false,\n  checkJoiners = false,\n  useSTD3ASCIIRules = false,\n  processingOption = \"nontransitional\",\n  verifyDNSLength = false\n} = {}) {\n  if (processingOption !== \"transitional\" && processingOption !== \"nontransitional\") {\n    throw new RangeError(\"processingOption must be either transitional or nontransitional\");\n  }\n\n  const result = processing(domainName, {\n    processingOption,\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules\n  });\n  let labels = result.string.split(\".\");\n  labels = labels.map(l => {\n    if (containsNonASCII(l)) {\n      try {\n        return \"xn--\" + punycode.encode(l);\n      } catch (e) {\n        result.error = true;\n      }\n    }\n    return l;\n  });\n\n  if (verifyDNSLength) {\n    const total = labels.join(\".\").length;\n    if (total > 253 || total === 0) {\n      result.error = true;\n    }\n\n    for (let i = 0; i < labels.length; ++i) {\n      if (labels[i].length > 63 || labels[i].length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n\n  if (result.error) {\n    return null;\n  }\n  return labels.join(\".\");\n}\n\nfunction toUnicode(domainName, {\n  checkHyphens = false,\n  checkBidi = false,\n  checkJoiners = false,\n  useSTD3ASCIIRules = false\n} = {}) {\n  const result = processing(domainName, {\n    processingOption: \"nontransitional\",\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules\n  });\n\n  return {\n    domain: result.string,\n    error: result.error\n  };\n}\n\nmodule.exports = {\n  toASCII,\n  toUnicode\n};\n"]},"metadata":{},"sourceType":"script"}