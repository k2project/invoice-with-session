{"ast":null,"code":"\"use strict\";\n\nconst request = require(\"request\");\n\nconst {\n  EventEmitter\n} = require(\"events\");\n\nconst Event = require(\"./generated/Event\");\n\nconst ProgressEvent = require(\"./generated/ProgressEvent\");\n\nconst fs = require(\"fs\");\n\nconst {\n  URL\n} = require(\"whatwg-url\");\n\nconst parseDataURL = require(\"data-urls\");\n\nconst DOMException = require(\"domexception\");\n\nconst xhrSymbols = require(\"./xmlhttprequest-symbols\");\n\nconst headerListSeparatorRegexp = /,[ \\t]*/;\nconst simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nconst simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\nconst preflightHeaders = new Set([\"access-control-expose-headers\", \"access-control-allow-headers\", \"access-control-allow-credentials\", \"access-control-allow-origin\"]);\n\nfunction wrapCookieJarForRequest(cookieJar) {\n  const jarWrapper = request.jar();\n  jarWrapper._jar = cookieJar;\n  return jarWrapper;\n}\n\nfunction getRequestHeader(requestHeaders, header) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n\n  while (n--) {\n    const key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n\n  return null;\n}\n\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n\n  while (n--) {\n    const key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\n\nfunction mergeHeaders(lhs, rhs) {\n  const rhsParts = rhs.split(\",\");\n  const lhsParts = lhs.split(\",\");\n  return rhsParts.concat(lhsParts.filter(p => rhsParts.indexOf(p) < 0)).join(\",\");\n}\n\nfunction dispatchError(xhr) {\n  const errMessage = xhr[xhrSymbols.properties].error;\n  requestErrorSteps(xhr, \"error\", new DOMException(errMessage, \"NetworkError\"));\n\n  if (xhr._ownerDocument) {\n    const error = new Error(errMessage);\n    error.type = \"XMLHttpRequest\";\n\n    xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n  }\n}\n\nfunction validCORSHeaders(xhr, response, flag, properties, origin) {\n  const acaoStr = response.headers[\"access-control-allow-origin\"];\n  const acao = acaoStr ? acaoStr.trim() : null;\n\n  if (acao !== \"*\" && acao !== origin) {\n    properties.error = \"Cross origin \" + origin + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  const acacStr = response.headers[\"access-control-allow-credentials\"];\n  const acac = acacStr ? acacStr.trim() : null;\n\n  if (flag.withCredentials && acac !== \"true\") {\n    properties.error = \"Credentials forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  return true;\n}\n\nfunction validCORSPreflightHeaders(xhr, response, flag, properties) {\n  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n    return false;\n  }\n\n  const acahStr = response.headers[\"access-control-allow-headers\"];\n  const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n  const forbiddenHeaders = Object.keys(flag.requestHeaders).filter(header => {\n    const lcHeader = header.toLowerCase();\n    return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n  });\n\n  if (forbiddenHeaders.length > 0) {\n    properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  return true;\n}\n\nfunction requestErrorSteps(xhr, event, exception) {\n  const properties = xhr[xhrSymbols.properties];\n  const flag = xhr[xhrSymbols.flag];\n  properties.readyState = xhr.DONE;\n  properties.send = false;\n  setResponseToNetworkError(xhr);\n\n  if (flag.synchronous) {\n    throw exception;\n  }\n\n  xhr.dispatchEvent(Event.create([\"readystatechange\"]));\n\n  if (!properties.uploadComplete) {\n    properties.uploadComplete = true;\n\n    if (properties.uploadListener) {\n      xhr.upload.dispatchEvent(ProgressEvent.create([event, {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      }]));\n      xhr.upload.dispatchEvent(ProgressEvent.create([\"loadend\", {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      }]));\n    }\n  }\n\n  xhr.dispatchEvent(ProgressEvent.create([event, {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  }]));\n  xhr.dispatchEvent(ProgressEvent.create([\"loadend\", {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  }]));\n}\n\nfunction setResponseToNetworkError(xhr) {\n  const properties = xhr[xhrSymbols.properties];\n  properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n  properties.responseHeaders = {};\n  properties.status = 0;\n  properties.statusText = \"\";\n} // return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\n\n\nfunction createClient(xhr) {\n  const flag = xhr[xhrSymbols.flag];\n  const properties = xhr[xhrSymbols.properties];\n  const urlObj = new URL(flag.uri);\n  const uri = urlObj.href;\n  const ucMethod = flag.method.toUpperCase();\n  const {\n    requestManager\n  } = flag;\n\n  if (urlObj.protocol === \"file:\") {\n    const response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    response.request = {\n      uri: urlObj\n    };\n    const filePath = urlObj.pathname.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, \"$1:/\").replace(/%20/g, \" \");\n    const client = new EventEmitter();\n    const readableStream = fs.createReadStream(filePath, {\n      encoding: null\n    });\n    readableStream.on(\"data\", chunk => {\n      response.emit(\"data\", chunk);\n      client.emit(\"data\", chunk);\n    });\n    readableStream.on(\"end\", () => {\n      response.emit(\"end\");\n      client.emit(\"end\");\n    });\n    readableStream.on(\"error\", err => {\n      response.emit(\"error\", err);\n      client.emit(\"error\", err);\n    });\n\n    client.abort = function () {\n      readableStream.destroy();\n      client.emit(\"abort\");\n    };\n\n    if (requestManager) {\n      const req = {\n        abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n\n      };\n      requestManager.add(req);\n      const rmReq = requestManager.remove.bind(requestManager, req);\n      client.on(\"abort\", rmReq);\n      client.on(\"error\", rmReq);\n      client.on(\"end\", rmReq);\n    }\n\n    process.nextTick(() => client.emit(\"response\", response));\n    return client;\n  }\n\n  if (urlObj.protocol === \"data:\") {\n    const response = new EventEmitter();\n    response.request = {\n      uri: urlObj\n    };\n    const client = new EventEmitter();\n    let buffer;\n\n    try {\n      const parsed = parseDataURL(uri);\n      const contentType = parsed.mimeType.toString();\n      buffer = parsed.body;\n      response.statusCode = 200;\n      response.rawHeaders = [\"Content-Type\", contentType];\n      response.headers = {\n        \"content-type\": contentType\n      };\n    } catch (err) {\n      process.nextTick(() => client.emit(\"error\", err));\n      return client;\n    }\n\n    client.abort = () => {// do nothing\n    };\n\n    process.nextTick(() => {\n      client.emit(\"response\", response);\n      process.nextTick(() => {\n        response.emit(\"data\", buffer);\n        client.emit(\"data\", buffer);\n        response.emit(\"end\");\n        client.emit(\"end\");\n      });\n    });\n    return client;\n  }\n\n  const requestHeaders = {};\n\n  for (const header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n\n  const crossOrigin = flag.origin !== urlObj.origin;\n\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n\n  const options = {\n    uri,\n    method: flag.method,\n    headers: requestHeaders,\n    gzip: true,\n    maxRedirects: 21,\n    followAllRedirects: true,\n    encoding: null,\n    pool: flag.pool,\n    agentOptions: flag.agentOptions,\n    strictSSL: flag.strictSSL\n  };\n\n  if (flag.auth) {\n    options.auth = {\n      user: flag.auth.user || \"\",\n      pass: flag.auth.pass || \"\",\n      sendImmediately: false\n    };\n  }\n\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.jar = wrapCookieJarForRequest(flag.cookieJar);\n  }\n\n  if (flag.proxy) {\n    options.proxy = flag.proxy;\n  }\n\n  const {\n    body\n  } = flag;\n  const hasBody = body !== undefined && body !== null && body !== \"\" && !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n\n  if (hasBody && !flag.formData) {\n    options.body = body;\n  }\n\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n\n  function doRequest() {\n    try {\n      const client = request(options);\n\n      if (hasBody && flag.formData) {\n        const form = client.form();\n\n        for (const entry of body) {\n          form.append(entry.name, entry.value, entry.options);\n        }\n      }\n\n      return client;\n    } catch (e) {\n      const client = new EventEmitter();\n      process.nextTick(() => client.emit(\"error\", e));\n      return client;\n    }\n  }\n\n  let client;\n  const nonSimpleHeaders = Object.keys(flag.requestHeaders).filter(header => !simpleHeaders.has(header.toLowerCase()));\n\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0 || properties.uploadListener)) {\n    client = new EventEmitter();\n    const preflightRequestHeaders = [];\n\n    for (const header in requestHeaders) {\n      // the only existing request headers the cors spec allows on the preflight request are Origin and Referrer\n      const lcHeader = header.toLowerCase();\n\n      if (lcHeader === \"origin\" || lcHeader === \"referrer\") {\n        preflightRequestHeaders[header] = requestHeaders[header];\n      }\n    }\n\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n\n    preflightRequestHeaders[\"User-Agent\"] = flag.userAgent;\n    flag.preflight = true;\n    const preflightOptions = {\n      uri,\n      method: \"OPTIONS\",\n      headers: preflightRequestHeaders,\n      followRedirect: false,\n      encoding: null,\n      pool: flag.pool,\n      agentOptions: flag.agentOptions,\n      strictSSL: flag.strictSSL\n    };\n\n    if (flag.proxy) {\n      preflightOptions.proxy = flag.proxy;\n    }\n\n    const preflightClient = request(preflightOptions);\n    preflightClient.on(\"response\", resp => {\n      // don't send the real request if the preflight request returned an error\n      if (resp.statusCode < 200 || resp.statusCode > 299) {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n        return;\n      } // don't send the real request if we aren't allowed to use the headers\n\n\n      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {\n        setResponseToNetworkError(xhr);\n        return;\n      }\n\n      const realClient = doRequest();\n      realClient.on(\"response\", res => {\n        for (const header in resp.headers) {\n          if (preflightHeaders.has(header)) {\n            res.headers[header] = Object.prototype.hasOwnProperty.call(res.headers, header) ? mergeHeaders(res.headers[header], resp.headers[header]) : resp.headers[header];\n          }\n        }\n\n        client.emit(\"response\", res);\n      });\n      realClient.on(\"data\", chunk => client.emit(\"data\", chunk));\n      realClient.on(\"end\", () => client.emit(\"end\"));\n      realClient.on(\"abort\", () => client.emit(\"abort\"));\n      realClient.on(\"request\", req => {\n        client.headers = realClient.headers;\n        client.emit(\"request\", req);\n      });\n      realClient.on(\"redirect\", () => {\n        client.response = realClient.response;\n        client.emit(\"redirect\");\n      });\n      realClient.on(\"error\", err => client.emit(\"error\", err));\n\n      client.abort = () => {\n        realClient.abort();\n      };\n    });\n    preflightClient.on(\"error\", err => client.emit(\"error\", err));\n\n    client.abort = () => {\n      preflightClient.abort();\n    };\n  } else {\n    client = doRequest();\n  }\n\n  if (requestManager) {\n    const req = {\n      abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n\n    };\n    requestManager.add(req);\n    const rmReq = requestManager.remove.bind(requestManager, req);\n    client.on(\"abort\", rmReq);\n    client.on(\"error\", rmReq);\n    client.on(\"end\", rmReq);\n  }\n\n  return client;\n}\n\nexports.headerListSeparatorRegexp = headerListSeparatorRegexp;\nexports.simpleHeaders = simpleHeaders;\nexports.preflightHeaders = preflightHeaders;\nexports.wrapCookieJarForRequest = wrapCookieJarForRequest;\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.dispatchError = dispatchError;\nexports.validCORSHeaders = validCORSHeaders;\nexports.requestErrorSteps = requestErrorSteps;\nexports.setResponseToNetworkError = setResponseToNetworkError;\nexports.createClient = createClient;","map":{"version":3,"sources":["/Users/krispol/Desktop/invoice/invoice-with-session/client/node_modules/jsdom/lib/jsdom/living/xhr-utils.js"],"names":["request","require","EventEmitter","Event","ProgressEvent","fs","URL","parseDataURL","DOMException","xhrSymbols","headerListSeparatorRegexp","simpleMethods","Set","simpleHeaders","preflightHeaders","wrapCookieJarForRequest","cookieJar","jarWrapper","jar","_jar","getRequestHeader","requestHeaders","header","lcHeader","toLowerCase","keys","Object","n","length","key","updateRequestHeader","newValue","mergeHeaders","lhs","rhs","rhsParts","split","lhsParts","concat","filter","p","indexOf","join","dispatchError","xhr","errMessage","properties","error","requestErrorSteps","_ownerDocument","Error","type","_defaultView","_virtualConsole","emit","validCORSHeaders","response","flag","origin","acaoStr","headers","acao","trim","acacStr","acac","withCredentials","validCORSPreflightHeaders","acahStr","acah","forbiddenHeaders","has","event","exception","readyState","DONE","send","setResponseToNetworkError","synchronous","dispatchEvent","create","uploadComplete","uploadListener","upload","loaded","total","lengthComputable","responseCache","responseTextCache","responseXMLCache","responseHeaders","status","statusText","createClient","urlObj","uri","href","ucMethod","method","toUpperCase","requestManager","protocol","statusCode","rawHeaders","filePath","pathname","replace","client","readableStream","createReadStream","encoding","on","chunk","err","abort","destroy","req","abortError","add","rmReq","remove","bind","process","nextTick","buffer","parsed","contentType","mimeType","toString","body","Referer","referrer","userAgent","Accept","crossOrigin","Origin","options","gzip","maxRedirects","followAllRedirects","pool","agentOptions","strictSSL","auth","user","pass","sendImmediately","proxy","hasBody","undefined","formData","doRequest","form","entry","append","name","value","e","nonSimpleHeaders","preflightRequestHeaders","preflight","preflightOptions","followRedirect","preflightClient","resp","realClient","res","prototype","hasOwnProperty","call","exports"],"mappings":"AAAA;;AACA,MAAMA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAmBD,OAAO,CAAC,QAAD,CAAhC;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,mBAAD,CAArB;;AACA,MAAMG,aAAa,GAAGH,OAAO,CAAC,2BAAD,CAA7B;;AACA,MAAMI,EAAE,GAAGJ,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAUL,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAMM,YAAY,GAAGN,OAAO,CAAC,WAAD,CAA5B;;AAEA,MAAMO,YAAY,GAAGP,OAAO,CAAC,cAAD,CAA5B;;AACA,MAAMQ,UAAU,GAAGR,OAAO,CAAC,0BAAD,CAA1B;;AAEA,MAAMS,yBAAyB,GAAG,SAAlC;AACA,MAAMC,aAAa,GAAG,IAAIC,GAAJ,CAAQ,CAAC,KAAD,EAAQ,MAAR,EAAgB,MAAhB,CAAR,CAAtB;AACA,MAAMC,aAAa,GAAG,IAAID,GAAJ,CAAQ,CAAC,QAAD,EAAW,iBAAX,EAA8B,kBAA9B,EAAkD,cAAlD,CAAR,CAAtB;AACA,MAAME,gBAAgB,GAAG,IAAIF,GAAJ,CAAQ,CAC/B,+BAD+B,EAE/B,8BAF+B,EAG/B,kCAH+B,EAI/B,6BAJ+B,CAAR,CAAzB;;AAOA,SAASG,uBAAT,CAAiCC,SAAjC,EAA4C;AAC1C,QAAMC,UAAU,GAAGjB,OAAO,CAACkB,GAAR,EAAnB;AACAD,EAAAA,UAAU,CAACE,IAAX,GAAkBH,SAAlB;AACA,SAAOC,UAAP;AACD;;AAED,SAASG,gBAAT,CAA0BC,cAA1B,EAA0CC,MAA1C,EAAkD;AAChD,QAAMC,QAAQ,GAAGD,MAAM,CAACE,WAAP,EAAjB;AACA,QAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYJ,cAAZ,CAAb;AACA,MAAIM,CAAC,GAAGF,IAAI,CAACG,MAAb;;AACA,SAAOD,CAAC,EAAR,EAAY;AACV,UAAME,GAAG,GAAGJ,IAAI,CAACE,CAAD,CAAhB;;AACA,QAAIE,GAAG,CAACL,WAAJ,OAAsBD,QAA1B,EAAoC;AAClC,aAAOF,cAAc,CAACQ,GAAD,CAArB;AACD;AACF;;AACD,SAAO,IAAP;AACD;;AAED,SAASC,mBAAT,CAA6BT,cAA7B,EAA6CC,MAA7C,EAAqDS,QAArD,EAA+D;AAC7D,QAAMR,QAAQ,GAAGD,MAAM,CAACE,WAAP,EAAjB;AACA,QAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYJ,cAAZ,CAAb;AACA,MAAIM,CAAC,GAAGF,IAAI,CAACG,MAAb;;AACA,SAAOD,CAAC,EAAR,EAAY;AACV,UAAME,GAAG,GAAGJ,IAAI,CAACE,CAAD,CAAhB;;AACA,QAAIE,GAAG,CAACL,WAAJ,OAAsBD,QAA1B,EAAoC;AAClCF,MAAAA,cAAc,CAACQ,GAAD,CAAd,GAAsBE,QAAtB;AACD;AACF;AACF;;AAED,SAASC,YAAT,CAAsBC,GAAtB,EAA2BC,GAA3B,EAAgC;AAC9B,QAAMC,QAAQ,GAAGD,GAAG,CAACE,KAAJ,CAAU,GAAV,CAAjB;AACA,QAAMC,QAAQ,GAAGJ,GAAG,CAACG,KAAJ,CAAU,GAAV,CAAjB;AACA,SAAOD,QAAQ,CAACG,MAAT,CAAgBD,QAAQ,CAACE,MAAT,CAAgBC,CAAC,IAAIL,QAAQ,CAACM,OAAT,CAAiBD,CAAjB,IAAsB,CAA3C,CAAhB,EAA+DE,IAA/D,CAAoE,GAApE,CAAP;AACD;;AAED,SAASC,aAAT,CAAuBC,GAAvB,EAA4B;AAC1B,QAAMC,UAAU,GAAGD,GAAG,CAACnC,UAAU,CAACqC,UAAZ,CAAH,CAA2BC,KAA9C;AACAC,EAAAA,iBAAiB,CAACJ,GAAD,EAAM,OAAN,EAAe,IAAIpC,YAAJ,CAAiBqC,UAAjB,EAA6B,cAA7B,CAAf,CAAjB;;AAEA,MAAID,GAAG,CAACK,cAAR,EAAwB;AACtB,UAAMF,KAAK,GAAG,IAAIG,KAAJ,CAAUL,UAAV,CAAd;AACAE,IAAAA,KAAK,CAACI,IAAN,GAAa,gBAAb;;AAEAP,IAAAA,GAAG,CAACK,cAAJ,CAAmBG,YAAnB,CAAgCC,eAAhC,CAAgDC,IAAhD,CAAqD,YAArD,EAAmEP,KAAnE;AACD;AACF;;AAED,SAASQ,gBAAT,CAA0BX,GAA1B,EAA+BY,QAA/B,EAAyCC,IAAzC,EAA+CX,UAA/C,EAA2DY,MAA3D,EAAmE;AACjE,QAAMC,OAAO,GAAGH,QAAQ,CAACI,OAAT,CAAiB,6BAAjB,CAAhB;AACA,QAAMC,IAAI,GAAGF,OAAO,GAAGA,OAAO,CAACG,IAAR,EAAH,GAAoB,IAAxC;;AACA,MAAID,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAKH,MAA7B,EAAqC;AACnCZ,IAAAA,UAAU,CAACC,KAAX,GAAmB,kBAAkBW,MAAlB,GAA2B,YAA9C;AACAf,IAAAA,aAAa,CAACC,GAAD,CAAb;AACA,WAAO,KAAP;AACD;;AACD,QAAMmB,OAAO,GAAGP,QAAQ,CAACI,OAAT,CAAiB,kCAAjB,CAAhB;AACA,QAAMI,IAAI,GAAGD,OAAO,GAAGA,OAAO,CAACD,IAAR,EAAH,GAAoB,IAAxC;;AACA,MAAIL,IAAI,CAACQ,eAAL,IAAwBD,IAAI,KAAK,MAArC,EAA6C;AAC3ClB,IAAAA,UAAU,CAACC,KAAX,GAAmB,uBAAnB;AACAJ,IAAAA,aAAa,CAACC,GAAD,CAAb;AACA,WAAO,KAAP;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASsB,yBAAT,CAAmCtB,GAAnC,EAAwCY,QAAxC,EAAkDC,IAAlD,EAAwDX,UAAxD,EAAoE;AAClE,MAAI,CAACS,gBAAgB,CAACX,GAAD,EAAMY,QAAN,EAAgBC,IAAhB,EAAsBX,UAAtB,EAAkCA,UAAU,CAACY,MAA7C,CAArB,EAA2E;AACzE,WAAO,KAAP;AACD;;AACD,QAAMS,OAAO,GAAGX,QAAQ,CAACI,OAAT,CAAiB,8BAAjB,CAAhB;AACA,QAAMQ,IAAI,GAAG,IAAIxD,GAAJ,CAAQuD,OAAO,GAAGA,OAAO,CAACL,IAAR,GAAetC,WAAf,GAA6BY,KAA7B,CAAmC1B,yBAAnC,CAAH,GAAmE,EAAlF,CAAb;AACA,QAAM2D,gBAAgB,GAAG3C,MAAM,CAACD,IAAP,CAAYgC,IAAI,CAACpC,cAAjB,EAAiCkB,MAAjC,CAAwCjB,MAAM,IAAI;AACzE,UAAMC,QAAQ,GAAGD,MAAM,CAACE,WAAP,EAAjB;AACA,WAAO,CAACX,aAAa,CAACyD,GAAd,CAAkB/C,QAAlB,CAAD,IAAgC,CAAC6C,IAAI,CAACE,GAAL,CAAS/C,QAAT,CAAxC;AACD,GAHwB,CAAzB;;AAIA,MAAI8C,gBAAgB,CAACzC,MAAjB,GAA0B,CAA9B,EAAiC;AAC/BkB,IAAAA,UAAU,CAACC,KAAX,GAAmB,aAAasB,gBAAb,GAAgC,YAAnD;AACA1B,IAAAA,aAAa,CAACC,GAAD,CAAb;AACA,WAAO,KAAP;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASI,iBAAT,CAA2BJ,GAA3B,EAAgC2B,KAAhC,EAAuCC,SAAvC,EAAkD;AAChD,QAAM1B,UAAU,GAAGF,GAAG,CAACnC,UAAU,CAACqC,UAAZ,CAAtB;AACA,QAAMW,IAAI,GAAGb,GAAG,CAACnC,UAAU,CAACgD,IAAZ,CAAhB;AAEAX,EAAAA,UAAU,CAAC2B,UAAX,GAAwB7B,GAAG,CAAC8B,IAA5B;AACA5B,EAAAA,UAAU,CAAC6B,IAAX,GAAkB,KAAlB;AAEAC,EAAAA,yBAAyB,CAAChC,GAAD,CAAzB;;AAEA,MAAIa,IAAI,CAACoB,WAAT,EAAsB;AACpB,UAAML,SAAN;AACD;;AAED5B,EAAAA,GAAG,CAACkC,aAAJ,CAAkB3E,KAAK,CAAC4E,MAAN,CAAa,CAAC,kBAAD,CAAb,CAAlB;;AAEA,MAAI,CAACjC,UAAU,CAACkC,cAAhB,EAAgC;AAC9BlC,IAAAA,UAAU,CAACkC,cAAX,GAA4B,IAA5B;;AAEA,QAAIlC,UAAU,CAACmC,cAAf,EAA+B;AAC7BrC,MAAAA,GAAG,CAACsC,MAAJ,CAAWJ,aAAX,CAAyB1E,aAAa,CAAC2E,MAAd,CAAqB,CAACR,KAAD,EAAQ;AAAEY,QAAAA,MAAM,EAAE,CAAV;AAAaC,QAAAA,KAAK,EAAE,CAApB;AAAuBC,QAAAA,gBAAgB,EAAE;AAAzC,OAAR,CAArB,CAAzB;AACAzC,MAAAA,GAAG,CAACsC,MAAJ,CAAWJ,aAAX,CAAyB1E,aAAa,CAAC2E,MAAd,CAAqB,CAAC,SAAD,EAAY;AAAEI,QAAAA,MAAM,EAAE,CAAV;AAAaC,QAAAA,KAAK,EAAE,CAApB;AAAuBC,QAAAA,gBAAgB,EAAE;AAAzC,OAAZ,CAArB,CAAzB;AACD;AACF;;AAEDzC,EAAAA,GAAG,CAACkC,aAAJ,CAAkB1E,aAAa,CAAC2E,MAAd,CAAqB,CAACR,KAAD,EAAQ;AAAEY,IAAAA,MAAM,EAAE,CAAV;AAAaC,IAAAA,KAAK,EAAE,CAApB;AAAuBC,IAAAA,gBAAgB,EAAE;AAAzC,GAAR,CAArB,CAAlB;AACAzC,EAAAA,GAAG,CAACkC,aAAJ,CAAkB1E,aAAa,CAAC2E,MAAd,CAAqB,CAAC,SAAD,EAAY;AAAEI,IAAAA,MAAM,EAAE,CAAV;AAAaC,IAAAA,KAAK,EAAE,CAApB;AAAuBC,IAAAA,gBAAgB,EAAE;AAAzC,GAAZ,CAArB,CAAlB;AACD;;AAED,SAAST,yBAAT,CAAmChC,GAAnC,EAAwC;AACtC,QAAME,UAAU,GAAGF,GAAG,CAACnC,UAAU,CAACqC,UAAZ,CAAtB;AACAA,EAAAA,UAAU,CAACwC,aAAX,GAA2BxC,UAAU,CAACyC,iBAAX,GAA+BzC,UAAU,CAAC0C,gBAAX,GAA8B,IAAxF;AACA1C,EAAAA,UAAU,CAAC2C,eAAX,GAA6B,EAA7B;AACA3C,EAAAA,UAAU,CAAC4C,MAAX,GAAoB,CAApB;AACA5C,EAAAA,UAAU,CAAC6C,UAAX,GAAwB,EAAxB;AACD,C,CAED;AACA;;;AACA,SAASC,YAAT,CAAsBhD,GAAtB,EAA2B;AACzB,QAAMa,IAAI,GAAGb,GAAG,CAACnC,UAAU,CAACgD,IAAZ,CAAhB;AACA,QAAMX,UAAU,GAAGF,GAAG,CAACnC,UAAU,CAACqC,UAAZ,CAAtB;AACA,QAAM+C,MAAM,GAAG,IAAIvF,GAAJ,CAAQmD,IAAI,CAACqC,GAAb,CAAf;AACA,QAAMA,GAAG,GAAGD,MAAM,CAACE,IAAnB;AACA,QAAMC,QAAQ,GAAGvC,IAAI,CAACwC,MAAL,CAAYC,WAAZ,EAAjB;AAEA,QAAM;AAAEC,IAAAA;AAAF,MAAqB1C,IAA3B;;AAEA,MAAIoC,MAAM,CAACO,QAAP,KAAoB,OAAxB,EAAiC;AAC/B,UAAM5C,QAAQ,GAAG,IAAItD,YAAJ,EAAjB;AACAsD,IAAAA,QAAQ,CAAC6C,UAAT,GAAsB,GAAtB;AACA7C,IAAAA,QAAQ,CAAC8C,UAAT,GAAsB,EAAtB;AACA9C,IAAAA,QAAQ,CAACI,OAAT,GAAmB,EAAnB;AACAJ,IAAAA,QAAQ,CAACxD,OAAT,GAAmB;AAAE8F,MAAAA,GAAG,EAAED;AAAP,KAAnB;AACA,UAAMU,QAAQ,GAAGV,MAAM,CAACW,QAAP,CACdC,OADc,CACN,YADM,EACQ,EADR,EAEdA,OAFc,CAEN,gBAFM,EAEY,MAFZ,EAGdA,OAHc,CAGN,MAHM,EAGE,GAHF,CAAjB;AAKA,UAAMC,MAAM,GAAG,IAAIxG,YAAJ,EAAf;AAEA,UAAMyG,cAAc,GAAGtG,EAAE,CAACuG,gBAAH,CAAoBL,QAApB,EAA8B;AAAEM,MAAAA,QAAQ,EAAE;AAAZ,KAA9B,CAAvB;AAEAF,IAAAA,cAAc,CAACG,EAAf,CAAkB,MAAlB,EAA0BC,KAAK,IAAI;AACjCvD,MAAAA,QAAQ,CAACF,IAAT,CAAc,MAAd,EAAsByD,KAAtB;AACAL,MAAAA,MAAM,CAACpD,IAAP,CAAY,MAAZ,EAAoByD,KAApB;AACD,KAHD;AAKAJ,IAAAA,cAAc,CAACG,EAAf,CAAkB,KAAlB,EAAyB,MAAM;AAC7BtD,MAAAA,QAAQ,CAACF,IAAT,CAAc,KAAd;AACAoD,MAAAA,MAAM,CAACpD,IAAP,CAAY,KAAZ;AACD,KAHD;AAKAqD,IAAAA,cAAc,CAACG,EAAf,CAAkB,OAAlB,EAA2BE,GAAG,IAAI;AAChCxD,MAAAA,QAAQ,CAACF,IAAT,CAAc,OAAd,EAAuB0D,GAAvB;AACAN,MAAAA,MAAM,CAACpD,IAAP,CAAY,OAAZ,EAAqB0D,GAArB;AACD,KAHD;;AAKAN,IAAAA,MAAM,CAACO,KAAP,GAAe,YAAY;AACzBN,MAAAA,cAAc,CAACO,OAAf;AACAR,MAAAA,MAAM,CAACpD,IAAP,CAAY,OAAZ;AACD,KAHD;;AAKA,QAAI6C,cAAJ,EAAoB;AAClB,YAAMgB,GAAG,GAAG;AACVF,QAAAA,KAAK,GAAG;AACNnE,UAAAA,UAAU,CAACsE,UAAX,GAAwB,IAAxB;AACAxE,UAAAA,GAAG,CAACqE,KAAJ;AACD;;AAJS,OAAZ;AAMAd,MAAAA,cAAc,CAACkB,GAAf,CAAmBF,GAAnB;AACA,YAAMG,KAAK,GAAGnB,cAAc,CAACoB,MAAf,CAAsBC,IAAtB,CAA2BrB,cAA3B,EAA2CgB,GAA3C,CAAd;AACAT,MAAAA,MAAM,CAACI,EAAP,CAAU,OAAV,EAAmBQ,KAAnB;AACAZ,MAAAA,MAAM,CAACI,EAAP,CAAU,OAAV,EAAmBQ,KAAnB;AACAZ,MAAAA,MAAM,CAACI,EAAP,CAAU,KAAV,EAAiBQ,KAAjB;AACD;;AAEDG,IAAAA,OAAO,CAACC,QAAR,CAAiB,MAAMhB,MAAM,CAACpD,IAAP,CAAY,UAAZ,EAAwBE,QAAxB,CAAvB;AAEA,WAAOkD,MAAP;AACD;;AAED,MAAIb,MAAM,CAACO,QAAP,KAAoB,OAAxB,EAAiC;AAC/B,UAAM5C,QAAQ,GAAG,IAAItD,YAAJ,EAAjB;AAEAsD,IAAAA,QAAQ,CAACxD,OAAT,GAAmB;AAAE8F,MAAAA,GAAG,EAAED;AAAP,KAAnB;AAEA,UAAMa,MAAM,GAAG,IAAIxG,YAAJ,EAAf;AAEA,QAAIyH,MAAJ;;AACA,QAAI;AACF,YAAMC,MAAM,GAAGrH,YAAY,CAACuF,GAAD,CAA3B;AACA,YAAM+B,WAAW,GAAGD,MAAM,CAACE,QAAP,CAAgBC,QAAhB,EAApB;AACAJ,MAAAA,MAAM,GAAGC,MAAM,CAACI,IAAhB;AACAxE,MAAAA,QAAQ,CAAC6C,UAAT,GAAsB,GAAtB;AACA7C,MAAAA,QAAQ,CAAC8C,UAAT,GAAsB,CAAC,cAAD,EAAiBuB,WAAjB,CAAtB;AACArE,MAAAA,QAAQ,CAACI,OAAT,GAAmB;AAAE,wBAAgBiE;AAAlB,OAAnB;AACD,KAPD,CAOE,OAAOb,GAAP,EAAY;AACZS,MAAAA,OAAO,CAACC,QAAR,CAAiB,MAAMhB,MAAM,CAACpD,IAAP,CAAY,OAAZ,EAAqB0D,GAArB,CAAvB;AACA,aAAON,MAAP;AACD;;AAEDA,IAAAA,MAAM,CAACO,KAAP,GAAe,MAAM,CACnB;AACD,KAFD;;AAIAQ,IAAAA,OAAO,CAACC,QAAR,CAAiB,MAAM;AACrBhB,MAAAA,MAAM,CAACpD,IAAP,CAAY,UAAZ,EAAwBE,QAAxB;AACAiE,MAAAA,OAAO,CAACC,QAAR,CAAiB,MAAM;AACrBlE,QAAAA,QAAQ,CAACF,IAAT,CAAc,MAAd,EAAsBqE,MAAtB;AACAjB,QAAAA,MAAM,CAACpD,IAAP,CAAY,MAAZ,EAAoBqE,MAApB;AACAnE,QAAAA,QAAQ,CAACF,IAAT,CAAc,KAAd;AACAoD,QAAAA,MAAM,CAACpD,IAAP,CAAY,KAAZ;AACD,OALD;AAMD,KARD;AAUA,WAAOoD,MAAP;AACD;;AAED,QAAMrF,cAAc,GAAG,EAAvB;;AAEA,OAAK,MAAMC,MAAX,IAAqBmC,IAAI,CAACpC,cAA1B,EAA0C;AACxCA,IAAAA,cAAc,CAACC,MAAD,CAAd,GAAyBmC,IAAI,CAACpC,cAAL,CAAoBC,MAApB,CAAzB;AACD;;AAED,MAAIF,gBAAgB,CAACqC,IAAI,CAACpC,cAAN,EAAsB,SAAtB,CAAhB,KAAqD,IAAzD,EAA+D;AAC7DA,IAAAA,cAAc,CAAC4G,OAAf,GAAyBxE,IAAI,CAACyE,QAA9B;AACD;;AACD,MAAI9G,gBAAgB,CAACqC,IAAI,CAACpC,cAAN,EAAsB,YAAtB,CAAhB,KAAwD,IAA5D,EAAkE;AAChEA,IAAAA,cAAc,CAAC,YAAD,CAAd,GAA+BoC,IAAI,CAAC0E,SAApC;AACD;;AACD,MAAI/G,gBAAgB,CAACqC,IAAI,CAACpC,cAAN,EAAsB,iBAAtB,CAAhB,KAA6D,IAAjE,EAAuE;AACrEA,IAAAA,cAAc,CAAC,iBAAD,CAAd,GAAoC,IAApC;AACD;;AACD,MAAID,gBAAgB,CAACqC,IAAI,CAACpC,cAAN,EAAsB,QAAtB,CAAhB,KAAoD,IAAxD,EAA8D;AAC5DA,IAAAA,cAAc,CAAC+G,MAAf,GAAwB,KAAxB;AACD;;AAED,QAAMC,WAAW,GAAG5E,IAAI,CAACC,MAAL,KAAgBmC,MAAM,CAACnC,MAA3C;;AACA,MAAI2E,WAAJ,EAAiB;AACfhH,IAAAA,cAAc,CAACiH,MAAf,GAAwB7E,IAAI,CAACC,MAA7B;AACD;;AAED,QAAM6E,OAAO,GAAG;AACdzC,IAAAA,GADc;AAEdG,IAAAA,MAAM,EAAExC,IAAI,CAACwC,MAFC;AAGdrC,IAAAA,OAAO,EAAEvC,cAHK;AAIdmH,IAAAA,IAAI,EAAE,IAJQ;AAKdC,IAAAA,YAAY,EAAE,EALA;AAMdC,IAAAA,kBAAkB,EAAE,IANN;AAOd7B,IAAAA,QAAQ,EAAE,IAPI;AAQd8B,IAAAA,IAAI,EAAElF,IAAI,CAACkF,IARG;AASdC,IAAAA,YAAY,EAAEnF,IAAI,CAACmF,YATL;AAUdC,IAAAA,SAAS,EAAEpF,IAAI,CAACoF;AAVF,GAAhB;;AAYA,MAAIpF,IAAI,CAACqF,IAAT,EAAe;AACbP,IAAAA,OAAO,CAACO,IAAR,GAAe;AACbC,MAAAA,IAAI,EAAEtF,IAAI,CAACqF,IAAL,CAAUC,IAAV,IAAkB,EADX;AAEbC,MAAAA,IAAI,EAAEvF,IAAI,CAACqF,IAAL,CAAUE,IAAV,IAAkB,EAFX;AAGbC,MAAAA,eAAe,EAAE;AAHJ,KAAf;AAKD;;AACD,MAAIxF,IAAI,CAACzC,SAAL,KAAmB,CAACqH,WAAD,IAAgB5E,IAAI,CAACQ,eAAxC,CAAJ,EAA8D;AAC5DsE,IAAAA,OAAO,CAACrH,GAAR,GAAcH,uBAAuB,CAAC0C,IAAI,CAACzC,SAAN,CAArC;AACD;;AAED,MAAIyC,IAAI,CAACyF,KAAT,EAAgB;AACdX,IAAAA,OAAO,CAACW,KAAR,GAAgBzF,IAAI,CAACyF,KAArB;AACD;;AAED,QAAM;AAAElB,IAAAA;AAAF,MAAWvE,IAAjB;AACA,QAAM0F,OAAO,GAAGnB,IAAI,KAAKoB,SAAT,IACApB,IAAI,KAAK,IADT,IAEAA,IAAI,KAAK,EAFT,IAGA,EAAEhC,QAAQ,KAAK,MAAb,IAAuBA,QAAQ,KAAK,KAAtC,CAHhB;;AAKA,MAAImD,OAAO,IAAI,CAAC1F,IAAI,CAAC4F,QAArB,EAA+B;AAC7Bd,IAAAA,OAAO,CAACP,IAAR,GAAeA,IAAf;AACD;;AAED,MAAImB,OAAO,IAAI/H,gBAAgB,CAACqC,IAAI,CAACpC,cAAN,EAAsB,cAAtB,CAAhB,KAA0D,IAAzE,EAA+E;AAC7EA,IAAAA,cAAc,CAAC,cAAD,CAAd,GAAiC,0BAAjC;AACD;;AAED,WAASiI,SAAT,GAAqB;AACnB,QAAI;AACF,YAAM5C,MAAM,GAAG1G,OAAO,CAACuI,OAAD,CAAtB;;AAEA,UAAIY,OAAO,IAAI1F,IAAI,CAAC4F,QAApB,EAA8B;AAC5B,cAAME,IAAI,GAAG7C,MAAM,CAAC6C,IAAP,EAAb;;AACA,aAAK,MAAMC,KAAX,IAAoBxB,IAApB,EAA0B;AACxBuB,UAAAA,IAAI,CAACE,MAAL,CAAYD,KAAK,CAACE,IAAlB,EAAwBF,KAAK,CAACG,KAA9B,EAAqCH,KAAK,CAACjB,OAA3C;AACD;AACF;;AAED,aAAO7B,MAAP;AACD,KAXD,CAWE,OAAOkD,CAAP,EAAU;AACV,YAAMlD,MAAM,GAAG,IAAIxG,YAAJ,EAAf;AACAuH,MAAAA,OAAO,CAACC,QAAR,CAAiB,MAAMhB,MAAM,CAACpD,IAAP,CAAY,OAAZ,EAAqBsG,CAArB,CAAvB;AACA,aAAOlD,MAAP;AACD;AACF;;AAED,MAAIA,MAAJ;AAEA,QAAMmD,gBAAgB,GAAGnI,MAAM,CAACD,IAAP,CAAYgC,IAAI,CAACpC,cAAjB,EACtBkB,MADsB,CACfjB,MAAM,IAAI,CAACT,aAAa,CAACyD,GAAd,CAAkBhD,MAAM,CAACE,WAAP,EAAlB,CADI,CAAzB;;AAGA,MAAI6G,WAAW,KAAK,CAAC1H,aAAa,CAAC2D,GAAd,CAAkB0B,QAAlB,CAAD,IAAgC6D,gBAAgB,CAACjI,MAAjB,GAA0B,CAA1D,IAA+DkB,UAAU,CAACmC,cAA/E,CAAf,EAA+G;AAC7GyB,IAAAA,MAAM,GAAG,IAAIxG,YAAJ,EAAT;AAEA,UAAM4J,uBAAuB,GAAG,EAAhC;;AACA,SAAK,MAAMxI,MAAX,IAAqBD,cAArB,EAAqC;AACnC;AACA,YAAME,QAAQ,GAAGD,MAAM,CAACE,WAAP,EAAjB;;AACA,UAAID,QAAQ,KAAK,QAAb,IAAyBA,QAAQ,KAAK,UAA1C,EAAsD;AACpDuI,QAAAA,uBAAuB,CAACxI,MAAD,CAAvB,GAAkCD,cAAc,CAACC,MAAD,CAAhD;AACD;AACF;;AAEDwI,IAAAA,uBAAuB,CAAC,+BAAD,CAAvB,GAA2DrG,IAAI,CAACwC,MAAhE;;AACA,QAAI4D,gBAAgB,CAACjI,MAAjB,GAA0B,CAA9B,EAAiC;AAC/BkI,MAAAA,uBAAuB,CAAC,gCAAD,CAAvB,GAA4DD,gBAAgB,CAACnH,IAAjB,CAAsB,IAAtB,CAA5D;AACD;;AAEDoH,IAAAA,uBAAuB,CAAC,YAAD,CAAvB,GAAwCrG,IAAI,CAAC0E,SAA7C;AAEA1E,IAAAA,IAAI,CAACsG,SAAL,GAAiB,IAAjB;AAEA,UAAMC,gBAAgB,GAAG;AACvBlE,MAAAA,GADuB;AAEvBG,MAAAA,MAAM,EAAE,SAFe;AAGvBrC,MAAAA,OAAO,EAAEkG,uBAHc;AAIvBG,MAAAA,cAAc,EAAE,KAJO;AAKvBpD,MAAAA,QAAQ,EAAE,IALa;AAMvB8B,MAAAA,IAAI,EAAElF,IAAI,CAACkF,IANY;AAOvBC,MAAAA,YAAY,EAAEnF,IAAI,CAACmF,YAPI;AAQvBC,MAAAA,SAAS,EAAEpF,IAAI,CAACoF;AARO,KAAzB;;AAWA,QAAIpF,IAAI,CAACyF,KAAT,EAAgB;AACdc,MAAAA,gBAAgB,CAACd,KAAjB,GAAyBzF,IAAI,CAACyF,KAA9B;AACD;;AAED,UAAMgB,eAAe,GAAGlK,OAAO,CAACgK,gBAAD,CAA/B;AAEAE,IAAAA,eAAe,CAACpD,EAAhB,CAAmB,UAAnB,EAA+BqD,IAAI,IAAI;AACrC;AACA,UAAIA,IAAI,CAAC9D,UAAL,GAAkB,GAAlB,IAAyB8D,IAAI,CAAC9D,UAAL,GAAkB,GAA/C,EAAoD;AAClDK,QAAAA,MAAM,CAACpD,IAAP,CAAY,OAAZ,EAAqB,IAAIJ,KAAJ,CAAU,yDAAyDiH,IAAI,CAAC9D,UAAxE,CAArB;AACA;AACD,OALoC,CAMrC;;;AACA,UAAI,CAACnC,yBAAyB,CAACtB,GAAD,EAAMuH,IAAN,EAAY1G,IAAZ,EAAkBX,UAAlB,CAA9B,EAA6D;AAC3D8B,QAAAA,yBAAyB,CAAChC,GAAD,CAAzB;AACA;AACD;;AACD,YAAMwH,UAAU,GAAGd,SAAS,EAA5B;AACAc,MAAAA,UAAU,CAACtD,EAAX,CAAc,UAAd,EAA0BuD,GAAG,IAAI;AAC/B,aAAK,MAAM/I,MAAX,IAAqB6I,IAAI,CAACvG,OAA1B,EAAmC;AACjC,cAAI9C,gBAAgB,CAACwD,GAAjB,CAAqBhD,MAArB,CAAJ,EAAkC;AAChC+I,YAAAA,GAAG,CAACzG,OAAJ,CAAYtC,MAAZ,IAAsBI,MAAM,CAAC4I,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCH,GAAG,CAACzG,OAAzC,EAAkDtC,MAAlD,IACAU,YAAY,CAACqI,GAAG,CAACzG,OAAJ,CAAYtC,MAAZ,CAAD,EAAsB6I,IAAI,CAACvG,OAAL,CAAatC,MAAb,CAAtB,CADZ,GAEA6I,IAAI,CAACvG,OAAL,CAAatC,MAAb,CAFtB;AAGD;AACF;;AACDoF,QAAAA,MAAM,CAACpD,IAAP,CAAY,UAAZ,EAAwB+G,GAAxB;AACD,OATD;AAUAD,MAAAA,UAAU,CAACtD,EAAX,CAAc,MAAd,EAAsBC,KAAK,IAAIL,MAAM,CAACpD,IAAP,CAAY,MAAZ,EAAoByD,KAApB,CAA/B;AACAqD,MAAAA,UAAU,CAACtD,EAAX,CAAc,KAAd,EAAqB,MAAMJ,MAAM,CAACpD,IAAP,CAAY,KAAZ,CAA3B;AACA8G,MAAAA,UAAU,CAACtD,EAAX,CAAc,OAAd,EAAuB,MAAMJ,MAAM,CAACpD,IAAP,CAAY,OAAZ,CAA7B;AACA8G,MAAAA,UAAU,CAACtD,EAAX,CAAc,SAAd,EAAyBK,GAAG,IAAI;AAC9BT,QAAAA,MAAM,CAAC9C,OAAP,GAAiBwG,UAAU,CAACxG,OAA5B;AACA8C,QAAAA,MAAM,CAACpD,IAAP,CAAY,SAAZ,EAAuB6D,GAAvB;AACD,OAHD;AAIAiD,MAAAA,UAAU,CAACtD,EAAX,CAAc,UAAd,EAA0B,MAAM;AAC9BJ,QAAAA,MAAM,CAAClD,QAAP,GAAkB4G,UAAU,CAAC5G,QAA7B;AACAkD,QAAAA,MAAM,CAACpD,IAAP,CAAY,UAAZ;AACD,OAHD;AAIA8G,MAAAA,UAAU,CAACtD,EAAX,CAAc,OAAd,EAAuBE,GAAG,IAAIN,MAAM,CAACpD,IAAP,CAAY,OAAZ,EAAqB0D,GAArB,CAA9B;;AACAN,MAAAA,MAAM,CAACO,KAAP,GAAe,MAAM;AACnBmD,QAAAA,UAAU,CAACnD,KAAX;AACD,OAFD;AAGD,KArCD;AAuCAiD,IAAAA,eAAe,CAACpD,EAAhB,CAAmB,OAAnB,EAA4BE,GAAG,IAAIN,MAAM,CAACpD,IAAP,CAAY,OAAZ,EAAqB0D,GAArB,CAAnC;;AAEAN,IAAAA,MAAM,CAACO,KAAP,GAAe,MAAM;AACnBiD,MAAAA,eAAe,CAACjD,KAAhB;AACD,KAFD;AAGD,GAlFD,MAkFO;AACLP,IAAAA,MAAM,GAAG4C,SAAS,EAAlB;AACD;;AAED,MAAInD,cAAJ,EAAoB;AAClB,UAAMgB,GAAG,GAAG;AACVF,MAAAA,KAAK,GAAG;AACNnE,QAAAA,UAAU,CAACsE,UAAX,GAAwB,IAAxB;AACAxE,QAAAA,GAAG,CAACqE,KAAJ;AACD;;AAJS,KAAZ;AAMAd,IAAAA,cAAc,CAACkB,GAAf,CAAmBF,GAAnB;AACA,UAAMG,KAAK,GAAGnB,cAAc,CAACoB,MAAf,CAAsBC,IAAtB,CAA2BrB,cAA3B,EAA2CgB,GAA3C,CAAd;AACAT,IAAAA,MAAM,CAACI,EAAP,CAAU,OAAV,EAAmBQ,KAAnB;AACAZ,IAAAA,MAAM,CAACI,EAAP,CAAU,OAAV,EAAmBQ,KAAnB;AACAZ,IAAAA,MAAM,CAACI,EAAP,CAAU,KAAV,EAAiBQ,KAAjB;AACD;;AAED,SAAOZ,MAAP;AACD;;AAED+D,OAAO,CAAC/J,yBAAR,GAAoCA,yBAApC;AACA+J,OAAO,CAAC5J,aAAR,GAAwBA,aAAxB;AACA4J,OAAO,CAAC3J,gBAAR,GAA2BA,gBAA3B;AACA2J,OAAO,CAAC1J,uBAAR,GAAkCA,uBAAlC;AACA0J,OAAO,CAACrJ,gBAAR,GAA2BA,gBAA3B;AACAqJ,OAAO,CAAC3I,mBAAR,GAA8BA,mBAA9B;AACA2I,OAAO,CAAC9H,aAAR,GAAwBA,aAAxB;AACA8H,OAAO,CAAClH,gBAAR,GAA2BA,gBAA3B;AACAkH,OAAO,CAACzH,iBAAR,GAA4BA,iBAA5B;AACAyH,OAAO,CAAC7F,yBAAR,GAAoCA,yBAApC;AACA6F,OAAO,CAAC7E,YAAR,GAAuBA,YAAvB","sourcesContent":["\"use strict\";\nconst request = require(\"request\");\nconst { EventEmitter } = require(\"events\");\nconst Event = require(\"./generated/Event\");\nconst ProgressEvent = require(\"./generated/ProgressEvent\");\nconst fs = require(\"fs\");\nconst { URL } = require(\"whatwg-url\");\nconst parseDataURL = require(\"data-urls\");\n\nconst DOMException = require(\"domexception\");\nconst xhrSymbols = require(\"./xmlhttprequest-symbols\");\n\nconst headerListSeparatorRegexp = /,[ \\t]*/;\nconst simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nconst simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\nconst preflightHeaders = new Set([\n  \"access-control-expose-headers\",\n  \"access-control-allow-headers\",\n  \"access-control-allow-credentials\",\n  \"access-control-allow-origin\"\n]);\n\nfunction wrapCookieJarForRequest(cookieJar) {\n  const jarWrapper = request.jar();\n  jarWrapper._jar = cookieJar;\n  return jarWrapper;\n}\n\nfunction getRequestHeader(requestHeaders, header) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n  return null;\n}\n\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  const lcHeader = header.toLowerCase();\n  const keys = Object.keys(requestHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\n\nfunction mergeHeaders(lhs, rhs) {\n  const rhsParts = rhs.split(\",\");\n  const lhsParts = lhs.split(\",\");\n  return rhsParts.concat(lhsParts.filter(p => rhsParts.indexOf(p) < 0)).join(\",\");\n}\n\nfunction dispatchError(xhr) {\n  const errMessage = xhr[xhrSymbols.properties].error;\n  requestErrorSteps(xhr, \"error\", new DOMException(errMessage, \"NetworkError\"));\n\n  if (xhr._ownerDocument) {\n    const error = new Error(errMessage);\n    error.type = \"XMLHttpRequest\";\n\n    xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n  }\n}\n\nfunction validCORSHeaders(xhr, response, flag, properties, origin) {\n  const acaoStr = response.headers[\"access-control-allow-origin\"];\n  const acao = acaoStr ? acaoStr.trim() : null;\n  if (acao !== \"*\" && acao !== origin) {\n    properties.error = \"Cross origin \" + origin + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  const acacStr = response.headers[\"access-control-allow-credentials\"];\n  const acac = acacStr ? acacStr.trim() : null;\n  if (flag.withCredentials && acac !== \"true\") {\n    properties.error = \"Credentials forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  return true;\n}\n\nfunction validCORSPreflightHeaders(xhr, response, flag, properties) {\n  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n    return false;\n  }\n  const acahStr = response.headers[\"access-control-allow-headers\"];\n  const acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n  const forbiddenHeaders = Object.keys(flag.requestHeaders).filter(header => {\n    const lcHeader = header.toLowerCase();\n    return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n  });\n  if (forbiddenHeaders.length > 0) {\n    properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n  return true;\n}\n\nfunction requestErrorSteps(xhr, event, exception) {\n  const properties = xhr[xhrSymbols.properties];\n  const flag = xhr[xhrSymbols.flag];\n\n  properties.readyState = xhr.DONE;\n  properties.send = false;\n\n  setResponseToNetworkError(xhr);\n\n  if (flag.synchronous) {\n    throw exception;\n  }\n\n  xhr.dispatchEvent(Event.create([\"readystatechange\"]));\n\n  if (!properties.uploadComplete) {\n    properties.uploadComplete = true;\n\n    if (properties.uploadListener) {\n      xhr.upload.dispatchEvent(ProgressEvent.create([event, { loaded: 0, total: 0, lengthComputable: false }]));\n      xhr.upload.dispatchEvent(ProgressEvent.create([\"loadend\", { loaded: 0, total: 0, lengthComputable: false }]));\n    }\n  }\n\n  xhr.dispatchEvent(ProgressEvent.create([event, { loaded: 0, total: 0, lengthComputable: false }]));\n  xhr.dispatchEvent(ProgressEvent.create([\"loadend\", { loaded: 0, total: 0, lengthComputable: false }]));\n}\n\nfunction setResponseToNetworkError(xhr) {\n  const properties = xhr[xhrSymbols.properties];\n  properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n  properties.responseHeaders = {};\n  properties.status = 0;\n  properties.statusText = \"\";\n}\n\n// return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\nfunction createClient(xhr) {\n  const flag = xhr[xhrSymbols.flag];\n  const properties = xhr[xhrSymbols.properties];\n  const urlObj = new URL(flag.uri);\n  const uri = urlObj.href;\n  const ucMethod = flag.method.toUpperCase();\n\n  const { requestManager } = flag;\n\n  if (urlObj.protocol === \"file:\") {\n    const response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    response.request = { uri: urlObj };\n    const filePath = urlObj.pathname\n      .replace(/^file:\\/\\//, \"\")\n      .replace(/^\\/([a-z]):\\//i, \"$1:/\")\n      .replace(/%20/g, \" \");\n\n    const client = new EventEmitter();\n\n    const readableStream = fs.createReadStream(filePath, { encoding: null });\n\n    readableStream.on(\"data\", chunk => {\n      response.emit(\"data\", chunk);\n      client.emit(\"data\", chunk);\n    });\n\n    readableStream.on(\"end\", () => {\n      response.emit(\"end\");\n      client.emit(\"end\");\n    });\n\n    readableStream.on(\"error\", err => {\n      response.emit(\"error\", err);\n      client.emit(\"error\", err);\n    });\n\n    client.abort = function () {\n      readableStream.destroy();\n      client.emit(\"abort\");\n    };\n\n    if (requestManager) {\n      const req = {\n        abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n      };\n      requestManager.add(req);\n      const rmReq = requestManager.remove.bind(requestManager, req);\n      client.on(\"abort\", rmReq);\n      client.on(\"error\", rmReq);\n      client.on(\"end\", rmReq);\n    }\n\n    process.nextTick(() => client.emit(\"response\", response));\n\n    return client;\n  }\n\n  if (urlObj.protocol === \"data:\") {\n    const response = new EventEmitter();\n\n    response.request = { uri: urlObj };\n\n    const client = new EventEmitter();\n\n    let buffer;\n    try {\n      const parsed = parseDataURL(uri);\n      const contentType = parsed.mimeType.toString();\n      buffer = parsed.body;\n      response.statusCode = 200;\n      response.rawHeaders = [\"Content-Type\", contentType];\n      response.headers = { \"content-type\": contentType };\n    } catch (err) {\n      process.nextTick(() => client.emit(\"error\", err));\n      return client;\n    }\n\n    client.abort = () => {\n      // do nothing\n    };\n\n    process.nextTick(() => {\n      client.emit(\"response\", response);\n      process.nextTick(() => {\n        response.emit(\"data\", buffer);\n        client.emit(\"data\", buffer);\n        response.emit(\"end\");\n        client.emit(\"end\");\n      });\n    });\n\n    return client;\n  }\n\n  const requestHeaders = {};\n\n  for (const header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n\n  const crossOrigin = flag.origin !== urlObj.origin;\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n\n  const options = {\n    uri,\n    method: flag.method,\n    headers: requestHeaders,\n    gzip: true,\n    maxRedirects: 21,\n    followAllRedirects: true,\n    encoding: null,\n    pool: flag.pool,\n    agentOptions: flag.agentOptions,\n    strictSSL: flag.strictSSL\n  };\n  if (flag.auth) {\n    options.auth = {\n      user: flag.auth.user || \"\",\n      pass: flag.auth.pass || \"\",\n      sendImmediately: false\n    };\n  }\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.jar = wrapCookieJarForRequest(flag.cookieJar);\n  }\n\n  if (flag.proxy) {\n    options.proxy = flag.proxy;\n  }\n\n  const { body } = flag;\n  const hasBody = body !== undefined &&\n                  body !== null &&\n                  body !== \"\" &&\n                  !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n\n  if (hasBody && !flag.formData) {\n    options.body = body;\n  }\n\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n\n  function doRequest() {\n    try {\n      const client = request(options);\n\n      if (hasBody && flag.formData) {\n        const form = client.form();\n        for (const entry of body) {\n          form.append(entry.name, entry.value, entry.options);\n        }\n      }\n\n      return client;\n    } catch (e) {\n      const client = new EventEmitter();\n      process.nextTick(() => client.emit(\"error\", e));\n      return client;\n    }\n  }\n\n  let client;\n\n  const nonSimpleHeaders = Object.keys(flag.requestHeaders)\n    .filter(header => !simpleHeaders.has(header.toLowerCase()));\n\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0 || properties.uploadListener)) {\n    client = new EventEmitter();\n\n    const preflightRequestHeaders = [];\n    for (const header in requestHeaders) {\n      // the only existing request headers the cors spec allows on the preflight request are Origin and Referrer\n      const lcHeader = header.toLowerCase();\n      if (lcHeader === \"origin\" || lcHeader === \"referrer\") {\n        preflightRequestHeaders[header] = requestHeaders[header];\n      }\n    }\n\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n\n    preflightRequestHeaders[\"User-Agent\"] = flag.userAgent;\n\n    flag.preflight = true;\n\n    const preflightOptions = {\n      uri,\n      method: \"OPTIONS\",\n      headers: preflightRequestHeaders,\n      followRedirect: false,\n      encoding: null,\n      pool: flag.pool,\n      agentOptions: flag.agentOptions,\n      strictSSL: flag.strictSSL\n    };\n\n    if (flag.proxy) {\n      preflightOptions.proxy = flag.proxy;\n    }\n\n    const preflightClient = request(preflightOptions);\n\n    preflightClient.on(\"response\", resp => {\n      // don't send the real request if the preflight request returned an error\n      if (resp.statusCode < 200 || resp.statusCode > 299) {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n        return;\n      }\n      // don't send the real request if we aren't allowed to use the headers\n      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {\n        setResponseToNetworkError(xhr);\n        return;\n      }\n      const realClient = doRequest();\n      realClient.on(\"response\", res => {\n        for (const header in resp.headers) {\n          if (preflightHeaders.has(header)) {\n            res.headers[header] = Object.prototype.hasOwnProperty.call(res.headers, header) ?\n                                  mergeHeaders(res.headers[header], resp.headers[header]) :\n                                  resp.headers[header];\n          }\n        }\n        client.emit(\"response\", res);\n      });\n      realClient.on(\"data\", chunk => client.emit(\"data\", chunk));\n      realClient.on(\"end\", () => client.emit(\"end\"));\n      realClient.on(\"abort\", () => client.emit(\"abort\"));\n      realClient.on(\"request\", req => {\n        client.headers = realClient.headers;\n        client.emit(\"request\", req);\n      });\n      realClient.on(\"redirect\", () => {\n        client.response = realClient.response;\n        client.emit(\"redirect\");\n      });\n      realClient.on(\"error\", err => client.emit(\"error\", err));\n      client.abort = () => {\n        realClient.abort();\n      };\n    });\n\n    preflightClient.on(\"error\", err => client.emit(\"error\", err));\n\n    client.abort = () => {\n      preflightClient.abort();\n    };\n  } else {\n    client = doRequest();\n  }\n\n  if (requestManager) {\n    const req = {\n      abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n    };\n    requestManager.add(req);\n    const rmReq = requestManager.remove.bind(requestManager, req);\n    client.on(\"abort\", rmReq);\n    client.on(\"error\", rmReq);\n    client.on(\"end\", rmReq);\n  }\n\n  return client;\n}\n\nexports.headerListSeparatorRegexp = headerListSeparatorRegexp;\nexports.simpleHeaders = simpleHeaders;\nexports.preflightHeaders = preflightHeaders;\nexports.wrapCookieJarForRequest = wrapCookieJarForRequest;\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.dispatchError = dispatchError;\nexports.validCORSHeaders = validCORSHeaders;\nexports.requestErrorSteps = requestErrorSteps;\nexports.setResponseToNetworkError = setResponseToNetworkError;\nexports.createClient = createClient;\n"]},"metadata":{},"sourceType":"script"}