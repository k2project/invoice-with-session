{"ast":null,"code":"\"use strict\";\n\nconst idlUtils = require(\"../generated/utils.js\");\n\nconst DOMException = require(\"domexception\");\n\nconst {\n  DOCUMENT_POSITION_CONTAINS,\n  DOCUMENT_POSITION_CONTAINED_BY\n} = require(\"../node-document-position\");\n\nconst Element = require(\"../generated/Element\");\n\nconst Node = require(\"../generated/Node\");\n\nconst HTMLCollectionImpl = require(\"./HTMLCollection-impl\").implementation;\n\nexports.implementation = class HTMLOptionsCollectionImpl extends HTMLCollectionImpl {\n  // inherits supported property indices\n  get length() {\n    this._update();\n\n    return this._list.length;\n  }\n\n  set length(value) {\n    this._update();\n\n    if (value > this._list.length) {\n      const doc = this._element._ownerDocument;\n\n      for (let i = this._list.length; i < value; i++) {\n        const el = doc.createElement(\"option\");\n\n        this._element.appendChild(el);\n      }\n    } else if (value < this._list.length) {\n      for (let i = this._list.length - 1; i >= value; i--) {\n        const el = this._list[i];\n\n        this._element.removeChild(el);\n      }\n    }\n  }\n\n  get [idlUtils.supportedPropertyNames]() {\n    this._update();\n\n    const result = new Set();\n\n    for (const element of this._list) {\n      result.add(element.getAttribute(\"id\"));\n      result.add(element.getAttribute(\"name\"));\n    }\n\n    return result;\n  }\n\n  [idlUtils.indexedSetNew](index, value) {\n    if (value === null) {\n      this.remove(index);\n      return;\n    }\n\n    this._update();\n\n    const {\n      length\n    } = this._list;\n    const n = index - length;\n\n    if (n > 0) {\n      const doc = this._element._ownerDocument;\n      const frag = doc.createDocumentFragment(); // Spec says n - 1, but n seems to be the right number here.\n\n      for (let i = 0; i < n; i++) {\n        const el = doc.createElement(\"option\");\n        frag.appendChild(el);\n      }\n\n      this._element.appendChild(frag);\n    }\n\n    if (n >= 0) {\n      this._element.appendChild(value);\n    } else {\n      this._element.replaceChild(value, this._list[index]);\n    }\n  }\n\n  [idlUtils.indexedSetExisting](index, value) {\n    return this[idlUtils.indexedSetNew](index, value);\n  }\n\n  add(element, before) {\n    if (this._element.compareDocumentPosition(element) & DOCUMENT_POSITION_CONTAINS) {\n      throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n    }\n\n    if (Element.isImpl(before) && !(this._element.compareDocumentPosition(before) & DOCUMENT_POSITION_CONTAINED_BY)) {\n      throw new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n    }\n\n    if (element === before) {\n      return;\n    }\n\n    let reference = null;\n\n    if (Node.isImpl(before)) {\n      reference = before;\n    } else if (typeof before === \"number\") {\n      this._update();\n\n      reference = this._list[before] || null;\n    }\n\n    const parent = reference !== null ? reference.parentNode : this._element;\n    parent.insertBefore(element, reference);\n  }\n\n  remove(index) {\n    this._update();\n\n    if (this._list.length === 0) {\n      return;\n    }\n\n    if (index < 0 || index >= this._list.length) {\n      return;\n    }\n\n    const element = this._list[index];\n    element.parentNode.removeChild(element);\n  }\n\n  get selectedIndex() {\n    return this._element.selectedIndex;\n  }\n\n  set selectedIndex(value) {\n    this._element.selectedIndex = value;\n  }\n\n};","map":{"version":3,"sources":["/Users/krispol/Desktop/invoice/invoice-with-session/client/node_modules/jsdom/lib/jsdom/living/nodes/HTMLOptionsCollection-impl.js"],"names":["idlUtils","require","DOMException","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_CONTAINED_BY","Element","Node","HTMLCollectionImpl","implementation","exports","HTMLOptionsCollectionImpl","length","_update","_list","value","doc","_element","_ownerDocument","i","el","createElement","appendChild","removeChild","supportedPropertyNames","result","Set","element","add","getAttribute","indexedSetNew","index","remove","n","frag","createDocumentFragment","replaceChild","indexedSetExisting","before","compareDocumentPosition","isImpl","reference","parent","parentNode","insertBefore","selectedIndex"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst idlUtils = require(\"../generated/utils.js\");\nconst DOMException = require(\"domexception\");\nconst { DOCUMENT_POSITION_CONTAINS, DOCUMENT_POSITION_CONTAINED_BY } = require(\"../node-document-position\");\nconst Element = require(\"../generated/Element\");\nconst Node = require(\"../generated/Node\");\nconst HTMLCollectionImpl = require(\"./HTMLCollection-impl\").implementation;\n\nexports.implementation = class HTMLOptionsCollectionImpl extends HTMLCollectionImpl {\n  // inherits supported property indices\n  get length() {\n    this._update();\n    return this._list.length;\n  }\n  set length(value) {\n    this._update();\n    if (value > this._list.length) {\n      const doc = this._element._ownerDocument;\n      for (let i = this._list.length; i < value; i++) {\n        const el = doc.createElement(\"option\");\n        this._element.appendChild(el);\n      }\n    } else if (value < this._list.length) {\n      for (let i = this._list.length - 1; i >= value; i--) {\n        const el = this._list[i];\n        this._element.removeChild(el);\n      }\n    }\n  }\n\n  get [idlUtils.supportedPropertyNames]() {\n    this._update();\n    const result = new Set();\n    for (const element of this._list) {\n      result.add(element.getAttribute(\"id\"));\n      result.add(element.getAttribute(\"name\"));\n    }\n    return result;\n  }\n  [idlUtils.indexedSetNew](index, value) {\n    if (value === null) {\n      this.remove(index);\n      return;\n    }\n    this._update();\n    const { length } = this._list;\n    const n = index - length;\n    if (n > 0) {\n      const doc = this._element._ownerDocument;\n      const frag = doc.createDocumentFragment();\n      // Spec says n - 1, but n seems to be the right number here.\n      for (let i = 0; i < n; i++) {\n        const el = doc.createElement(\"option\");\n        frag.appendChild(el);\n      }\n      this._element.appendChild(frag);\n    }\n    if (n >= 0) {\n      this._element.appendChild(value);\n    } else {\n      this._element.replaceChild(value, this._list[index]);\n    }\n  }\n  [idlUtils.indexedSetExisting](index, value) {\n    return this[idlUtils.indexedSetNew](index, value);\n  }\n  add(element, before) {\n    if (this._element.compareDocumentPosition(element) & DOCUMENT_POSITION_CONTAINS) {\n      throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n    }\n    if (Element.isImpl(before) && !(this._element.compareDocumentPosition(before) & DOCUMENT_POSITION_CONTAINED_BY)) {\n      throw new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n    }\n    if (element === before) {\n      return;\n    }\n\n    let reference = null;\n    if (Node.isImpl(before)) {\n      reference = before;\n    } else if (typeof before === \"number\") {\n      this._update();\n      reference = this._list[before] || null;\n    }\n\n    const parent = reference !== null ? reference.parentNode : this._element;\n    parent.insertBefore(element, reference);\n  }\n  remove(index) {\n    this._update();\n    if (this._list.length === 0) {\n      return;\n    }\n    if (index < 0 || index >= this._list.length) {\n      return;\n    }\n    const element = this._list[index];\n    element.parentNode.removeChild(element);\n  }\n  get selectedIndex() {\n    return this._element.selectedIndex;\n  }\n  set selectedIndex(value) {\n    this._element.selectedIndex = value;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}