{"ast":null,"code":"\"use strict\";\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\n\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\n\nconst {\n  simultaneousIterators\n} = require(\"../../utils\");\n\nconst DOMException = require(\"domexception\");\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\n\nconst NodeList = require(\"../generated/NodeList\");\n\nconst {\n  documentBaseURLSerialized\n} = require(\"../helpers/document-base-url\");\n\nconst {\n  clone,\n  locateNamespacePrefix,\n  locateNamespace\n} = require(\"../node\");\n\nconst attributes = require(\"../attributes\");\n\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE || node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE || node.nodeType === NODE_TYPE.NOTATION_NODE || //  node.nodeType === NODE_TYPE.ATTRIBUTE_NODE ||  // this is missing how do we handle?\n  node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId || a.systemId !== b.systemId) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName || a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributes.attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  for (const nodes of simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))) {\n    if (!nodes[0] || !nodes[1]) {\n      // mismatch in the amount of childNodes\n      return false;\n    }\n\n    if (!nodeEquals(nodes[0], nodes[1])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nclass NodeImpl extends EventTargetImpl {\n  constructor(args, privateData) {\n    super();\n    domSymbolTree.initialize(this);\n    this._ownerDocument = privateData.ownerDocument;\n    this._childNodesList = null;\n    this._childrenList = null;\n    this._version = 0;\n    this._memoizedQueries = {};\n  }\n\n  get parentNode() {\n    return domSymbolTree.parent(this);\n  }\n\n  getRootNode() {\n    // ignore option for composed, because of no Shadow DOM support\n    let root;\n\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      root = ancestor;\n    }\n\n    return root;\n  }\n\n  get nodeName() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        return this.tagName;\n\n      case NODE_TYPE.TEXT_NODE:\n        return \"#text\";\n\n      case NODE_TYPE.CDATA_SECTION_NODE:\n        return \"#cdata-section\";\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n\n      case NODE_TYPE.COMMENT_NODE:\n        return \"#comment\";\n\n      case NODE_TYPE.DOCUMENT_NODE:\n        return \"#document\";\n\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        return this.name;\n\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n    } // should never happen\n\n\n    return null;\n  }\n\n  get firstChild() {\n    return domSymbolTree.firstChild(this);\n  }\n\n  get isConnected() {\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      if (ancestor.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  get ownerDocument() {\n    return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n  }\n\n  get lastChild() {\n    return domSymbolTree.lastChild(this);\n  }\n\n  get childNodes() {\n    if (!this._childNodesList) {\n      this._childNodesList = NodeList.createImpl([], {\n        element: this,\n        query: () => domSymbolTree.childrenToArray(this)\n      });\n    } else {\n      this._childNodesList._update();\n    }\n\n    return this._childNodesList;\n  }\n\n  get nextSibling() {\n    return domSymbolTree.nextSibling(this);\n  }\n\n  get previousSibling() {\n    return domSymbolTree.previousSibling(this);\n  }\n\n  insertBefore(newChildImpl, refChildImpl) {\n    // DocumentType must be implicitly adopted\n    if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n      newChildImpl._ownerDocument = this._ownerDocument;\n    }\n\n    if (newChildImpl.nodeType && newChildImpl.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n    }\n\n    if (this._ownerDocument !== newChildImpl._ownerDocument) {\n      // adopt the node when it's not in this document\n      this._ownerDocument.adoptNode(newChildImpl);\n    } else {\n      // search for parents matching the newChild\n      for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n        if (ancestor === newChildImpl) {\n          throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n        }\n      }\n    } // fragments are merged into the element (except parser-created fragments in <template>)\n\n\n    if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      let grandChildImpl;\n\n      while (grandChildImpl = domSymbolTree.firstChild(newChildImpl)) {\n        newChildImpl.removeChild(grandChildImpl);\n        this.insertBefore(grandChildImpl, refChildImpl);\n      }\n    } else if (newChildImpl === refChildImpl) {\n      return newChildImpl;\n    } else {\n      const oldParentImpl = domSymbolTree.parent(newChildImpl); // if the newChild is already in the tree elsewhere, remove it first\n\n      if (oldParentImpl) {\n        oldParentImpl.removeChild(newChildImpl);\n      }\n\n      if (refChildImpl === null) {\n        domSymbolTree.appendChild(this, newChildImpl);\n      } else {\n        if (domSymbolTree.parent(refChildImpl) !== this) {\n          throw new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n        }\n\n        domSymbolTree.insertBefore(refChildImpl, newChildImpl);\n      }\n\n      this._modified();\n\n      if (newChildImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n        this._childTextContentChangeSteps();\n      }\n\n      if (this._attached && newChildImpl._attach) {\n        newChildImpl._attach();\n      }\n\n      this._descendantAdded(this, newChildImpl);\n    }\n\n    return newChildImpl;\n  } // raises(DOMException);\n\n\n  _modified() {\n    this._version++;\n\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      ancestor._version++;\n    }\n\n    if (this._childrenList) {\n      this._childrenList._update();\n    }\n\n    if (this._childNodesList) {\n      this._childNodesList._update();\n    }\n\n    this._clearMemoizedQueries();\n  }\n\n  _childTextContentChangeSteps() {// Default: do nothing\n  }\n\n  _clearMemoizedQueries() {\n    this._memoizedQueries = {};\n    const myParent = domSymbolTree.parent(this);\n\n    if (myParent) {\n      myParent._clearMemoizedQueries();\n    }\n  }\n\n  _descendantRemoved(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n\n    if (myParent) {\n      myParent._descendantRemoved(parent, child);\n    }\n  }\n\n  _descendantAdded(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n\n    if (myParent) {\n      myParent._descendantAdded(parent, child);\n    }\n  }\n\n  replaceChild(node, child) {\n    this.insertBefore(node, child);\n    return this.removeChild(child);\n  }\n\n  _attach() {\n    this._attached = true;\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._attach) {\n        child._attach();\n      }\n    }\n  }\n\n  _detach() {\n    this._attached = false;\n\n    if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n      this._ownerDocument._lastFocusedElement = null;\n    }\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._detach) {\n        child._detach();\n      }\n    }\n  }\n\n  removeChild(\n  /* Node */\n  oldChildImpl) {\n    if (!oldChildImpl || domSymbolTree.parent(oldChildImpl) !== this) {\n      throw new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n    }\n\n    if (this._ownerDocument) {\n      this._ownerDocument._runPreRemovingSteps(oldChildImpl);\n    }\n\n    domSymbolTree.remove(oldChildImpl);\n\n    this._modified();\n\n    oldChildImpl._detach();\n\n    this._descendantRemoved(this, oldChildImpl);\n\n    if (oldChildImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n      this._childTextContentChangeSteps();\n    }\n\n    return oldChildImpl;\n  } // raises(DOMException);\n\n\n  appendChild(newChild) {\n    return this.insertBefore(newChild, null);\n  }\n\n  hasChildNodes() {\n    return domSymbolTree.hasChildren(this);\n  }\n\n  normalize() {\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child.normalize) {\n        child.normalize();\n      } // Normalize should only transform Text nodes, and nothing else.\n\n\n      if (child.nodeType !== NODE_TYPE.TEXT_NODE) {\n        continue;\n      }\n\n      if (child.nodeValue === \"\") {\n        this.removeChild(child);\n        continue;\n      }\n\n      const prevChild = domSymbolTree.previousSibling(child);\n\n      if (prevChild && prevChild.nodeType === NODE_TYPE.TEXT_NODE) {\n        // merge text nodes\n        prevChild.appendData(child.nodeValue);\n        this.removeChild(child);\n      }\n    }\n  }\n\n  get parentElement() {\n    const parentNode = domSymbolTree.parent(this);\n    return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n  }\n\n  get baseURI() {\n    return documentBaseURLSerialized(this._ownerDocument);\n  }\n\n  compareDocumentPosition(otherImpl) {\n    // Let reference be the context object.\n    const reference = this;\n\n    if (isObsoleteNodeType(reference) || isObsoleteNodeType(otherImpl)) {\n      throw new Error(\"Obsolete node type\");\n    }\n\n    const result = domSymbolTree.compareTreePosition(reference, otherImpl); // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n    // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n\n    if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n      // symbol-tree does not add these bits required by the spec:\n      return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    return result;\n  }\n\n  lookupPrefix(namespace) {\n    if (namespace === null || namespace === \"\") {\n      return null;\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          return locateNamespacePrefix(this, namespace);\n        }\n\n      case NODE_TYPE.DOCUMENT_NODE:\n        {\n          return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n        }\n\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        {\n          return null;\n        }\n\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n        }\n\n      default:\n        {\n          return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n        }\n    }\n  }\n\n  lookupNamespaceURI(prefix) {\n    if (prefix === \"\") {\n      prefix = null;\n    }\n\n    return locateNamespace(this, prefix);\n  }\n\n  isDefaultNamespace(namespace) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    const defaultNamespace = locateNamespace(this, null);\n    return defaultNamespace === namespace;\n  }\n\n  contains(other) {\n    if (other === null) {\n      return false;\n    } else if (this === other) {\n      return true;\n    }\n\n    return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n  isEqualNode(node) {\n    if (node === null) {\n      return false;\n    } // Fast-path, not in the spec\n\n\n    if (this === node) {\n      return true;\n    }\n\n    return nodeEquals(this, node);\n  }\n\n  isSameNode(node) {\n    if (this === node) {\n      return true;\n    }\n\n    return false;\n  }\n\n  cloneNode(deep) {\n    deep = Boolean(deep);\n    return clone(this, undefined, deep);\n  }\n\n  get nodeValue() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._value;\n        }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          return this._data;\n        }\n\n      default:\n        {\n          return null;\n        }\n    }\n  }\n\n  set nodeValue(value) {\n    if (value === null) {\n      value = \"\";\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          attributes.setAnExistingAttributeValue(this, value);\n          break;\n        }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          this.replaceData(0, this.length, value);\n          break;\n        }\n    }\n  }\n\n  get textContent() {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          let text = \"\";\n\n          for (const child of domSymbolTree.treeIterator(this)) {\n            if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n              text += child.nodeValue;\n            }\n          }\n\n          return text;\n        }\n\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._value;\n        }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          return this._data;\n        }\n\n      default:\n        {\n          return null;\n        }\n    }\n  }\n\n  set textContent(value) {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          let child = domSymbolTree.firstChild(this);\n\n          while (child) {\n            this.removeChild(child);\n            child = domSymbolTree.firstChild(this);\n          }\n\n          if (value !== null && value !== \"\") {\n            this.appendChild(this._ownerDocument.createTextNode(value));\n          }\n\n          break;\n        }\n\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          attributes.setAnExistingAttributeValue(this, value);\n          break;\n        }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          this.replaceData(0, this.length, value);\n          break;\n        }\n    }\n  }\n\n}\n\nmodule.exports = {\n  implementation: NodeImpl\n};","map":{"version":3,"sources":["/Users/krispol/Desktop/invoice/invoice-with-session/client/node_modules/jsdom/lib/jsdom/living/nodes/Node-impl.js"],"names":["EventTargetImpl","require","implementation","domSymbolTree","simultaneousIterators","DOMException","NODE_TYPE","NODE_DOCUMENT_POSITION","NodeList","documentBaseURLSerialized","clone","locateNamespacePrefix","locateNamespace","attributes","isObsoleteNodeType","node","nodeType","ENTITY_NODE","ENTITY_REFERENCE_NODE","NOTATION_NODE","CDATA_SECTION_NODE","nodeEquals","a","b","DOCUMENT_TYPE_NODE","name","publicId","systemId","ELEMENT_NODE","_namespaceURI","_prefix","_localName","_attributes","length","PROCESSING_INSTRUCTION_NODE","_target","_data","TEXT_NODE","COMMENT_NODE","attributeListsEqual","nodes","childrenIterator","NodeImpl","constructor","args","privateData","initialize","_ownerDocument","ownerDocument","_childNodesList","_childrenList","_version","_memoizedQueries","parentNode","parent","getRootNode","root","ancestor","ancestorsIterator","nodeName","tagName","target","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","firstChild","isConnected","lastChild","childNodes","createImpl","element","query","childrenToArray","_update","nextSibling","previousSibling","insertBefore","newChildImpl","refChildImpl","ATTRIBUTE_NODE","adoptNode","grandChildImpl","removeChild","oldParentImpl","appendChild","_modified","_childTextContentChangeSteps","_attached","_attach","_descendantAdded","_clearMemoizedQueries","myParent","_descendantRemoved","child","replaceChild","_detach","_lastFocusedElement","oldChildImpl","_runPreRemovingSteps","remove","newChild","hasChildNodes","hasChildren","normalize","nodeValue","prevChild","appendData","parentElement","baseURI","compareDocumentPosition","otherImpl","reference","Error","result","compareTreePosition","DOCUMENT_POSITION_DISCONNECTED","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","DOCUMENT_POSITION_FOLLOWING","lookupPrefix","namespace","documentElement","_element","lookupNamespaceURI","prefix","isDefaultNamespace","defaultNamespace","contains","other","Boolean","DOCUMENT_POSITION_CONTAINED_BY","isEqualNode","isSameNode","cloneNode","deep","undefined","_value","value","setAnExistingAttributeValue","replaceData","textContent","text","treeIterator","createTextNode","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst { simultaneousIterators } = require(\"../../utils\");\nconst DOMException = require(\"domexception\");\nconst NODE_TYPE = require(\"../node-type\");\nconst NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\nconst NodeList = require(\"../generated/NodeList\");\nconst { documentBaseURLSerialized } = require(\"../helpers/document-base-url\");\nconst { clone, locateNamespacePrefix, locateNamespace } = require(\"../node\");\nconst attributes = require(\"../attributes\");\n\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE ||\n    node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE ||\n    node.nodeType === NODE_TYPE.NOTATION_NODE ||\n  //  node.nodeType === NODE_TYPE.ATTRIBUTE_NODE ||  // this is missing how do we handle?\n    node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId ||\n          a.systemId !== b.systemId) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName ||\n          a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributes.attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  for (const nodes of simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))) {\n    if (!nodes[0] || !nodes[1]) {\n      // mismatch in the amount of childNodes\n      return false;\n    }\n\n    if (!nodeEquals(nodes[0], nodes[1])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nclass NodeImpl extends EventTargetImpl {\n  constructor(args, privateData) {\n    super();\n\n    domSymbolTree.initialize(this);\n\n    this._ownerDocument = privateData.ownerDocument;\n\n    this._childNodesList = null;\n    this._childrenList = null;\n    this._version = 0;\n    this._memoizedQueries = {};\n  }\n\n  get parentNode() {\n    return domSymbolTree.parent(this);\n  }\n\n  getRootNode() {\n    // ignore option for composed, because of no Shadow DOM support\n    let root;\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      root = ancestor;\n    }\n    return root;\n  }\n\n  get nodeName() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        return this.tagName;\n      case NODE_TYPE.TEXT_NODE:\n        return \"#text\";\n      case NODE_TYPE.CDATA_SECTION_NODE:\n        return \"#cdata-section\";\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n      case NODE_TYPE.COMMENT_NODE:\n        return \"#comment\";\n      case NODE_TYPE.DOCUMENT_NODE:\n        return \"#document\";\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        return this.name;\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n    }\n\n    // should never happen\n    return null;\n  }\n\n  get firstChild() {\n    return domSymbolTree.firstChild(this);\n  }\n\n  get isConnected() {\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      if (ancestor.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  get ownerDocument() {\n    return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n  }\n\n  get lastChild() {\n    return domSymbolTree.lastChild(this);\n  }\n\n  get childNodes() {\n    if (!this._childNodesList) {\n      this._childNodesList = NodeList.createImpl([], {\n        element: this,\n        query: () => domSymbolTree.childrenToArray(this)\n      });\n    } else {\n      this._childNodesList._update();\n    }\n\n    return this._childNodesList;\n  }\n\n  get nextSibling() {\n    return domSymbolTree.nextSibling(this);\n  }\n\n  get previousSibling() {\n    return domSymbolTree.previousSibling(this);\n  }\n\n  insertBefore(newChildImpl, refChildImpl) {\n    // DocumentType must be implicitly adopted\n    if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n      newChildImpl._ownerDocument = this._ownerDocument;\n    }\n\n    if (newChildImpl.nodeType && newChildImpl.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n    }\n\n    if (this._ownerDocument !== newChildImpl._ownerDocument) {\n      // adopt the node when it's not in this document\n      this._ownerDocument.adoptNode(newChildImpl);\n    } else {\n      // search for parents matching the newChild\n      for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n        if (ancestor === newChildImpl) {\n          throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n        }\n      }\n    }\n\n    // fragments are merged into the element (except parser-created fragments in <template>)\n    if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      let grandChildImpl;\n      while ((grandChildImpl = domSymbolTree.firstChild(newChildImpl))) {\n        newChildImpl.removeChild(grandChildImpl);\n        this.insertBefore(grandChildImpl, refChildImpl);\n      }\n    } else if (newChildImpl === refChildImpl) {\n      return newChildImpl;\n    } else {\n      const oldParentImpl = domSymbolTree.parent(newChildImpl);\n      // if the newChild is already in the tree elsewhere, remove it first\n      if (oldParentImpl) {\n        oldParentImpl.removeChild(newChildImpl);\n      }\n\n      if (refChildImpl === null) {\n        domSymbolTree.appendChild(this, newChildImpl);\n      } else {\n        if (domSymbolTree.parent(refChildImpl) !== this) {\n          throw new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n        }\n\n        domSymbolTree.insertBefore(refChildImpl, newChildImpl);\n      }\n\n      this._modified();\n      if (newChildImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n        this._childTextContentChangeSteps();\n      }\n\n      if (this._attached && newChildImpl._attach) {\n        newChildImpl._attach();\n      }\n\n      this._descendantAdded(this, newChildImpl);\n    }\n\n    return newChildImpl;\n  } // raises(DOMException);\n\n  _modified() {\n    this._version++;\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      ancestor._version++;\n    }\n\n    if (this._childrenList) {\n      this._childrenList._update();\n    }\n    if (this._childNodesList) {\n      this._childNodesList._update();\n    }\n    this._clearMemoizedQueries();\n  }\n\n  _childTextContentChangeSteps() {\n    // Default: do nothing\n  }\n\n  _clearMemoizedQueries() {\n    this._memoizedQueries = {};\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._clearMemoizedQueries();\n    }\n  }\n\n  _descendantRemoved(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantRemoved(parent, child);\n    }\n  }\n\n  _descendantAdded(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantAdded(parent, child);\n    }\n  }\n\n  replaceChild(node, child) {\n    this.insertBefore(node, child);\n    return this.removeChild(child);\n  }\n\n  _attach() {\n    this._attached = true;\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._attach) {\n        child._attach();\n      }\n    }\n  }\n\n  _detach() {\n    this._attached = false;\n\n    if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n      this._ownerDocument._lastFocusedElement = null;\n    }\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._detach) {\n        child._detach();\n      }\n    }\n  }\n\n  removeChild(/* Node */ oldChildImpl) {\n    if (!oldChildImpl || domSymbolTree.parent(oldChildImpl) !== this) {\n      throw new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n    }\n\n    if (this._ownerDocument) {\n      this._ownerDocument._runPreRemovingSteps(oldChildImpl);\n    }\n    domSymbolTree.remove(oldChildImpl);\n    this._modified();\n    oldChildImpl._detach();\n    this._descendantRemoved(this, oldChildImpl);\n    if (oldChildImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n      this._childTextContentChangeSteps();\n    }\n    return oldChildImpl;\n  } // raises(DOMException);\n\n  appendChild(newChild) {\n    return this.insertBefore(newChild, null);\n  }\n\n  hasChildNodes() {\n    return domSymbolTree.hasChildren(this);\n  }\n\n  normalize() {\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child.normalize) {\n        child.normalize();\n      }\n\n      // Normalize should only transform Text nodes, and nothing else.\n      if (child.nodeType !== NODE_TYPE.TEXT_NODE) {\n        continue;\n      }\n\n      if (child.nodeValue === \"\") {\n        this.removeChild(child);\n        continue;\n      }\n\n      const prevChild = domSymbolTree.previousSibling(child);\n\n      if (prevChild && prevChild.nodeType === NODE_TYPE.TEXT_NODE) {\n        // merge text nodes\n        prevChild.appendData(child.nodeValue);\n        this.removeChild(child);\n      }\n    }\n  }\n\n  get parentElement() {\n    const parentNode = domSymbolTree.parent(this);\n    return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n  }\n\n  get baseURI() {\n    return documentBaseURLSerialized(this._ownerDocument);\n  }\n\n  compareDocumentPosition(otherImpl) {\n    // Let reference be the context object.\n    const reference = this;\n\n    if (isObsoleteNodeType(reference) || isObsoleteNodeType(otherImpl)) {\n      throw new Error(\"Obsolete node type\");\n    }\n\n    const result = domSymbolTree.compareTreePosition(reference, otherImpl);\n\n    // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n    // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n    if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n      // symbol-tree does not add these bits required by the spec:\n      return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    return result;\n  }\n\n  lookupPrefix(namespace) {\n    if (namespace === null || namespace === \"\") {\n      return null;\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE: {\n        return locateNamespacePrefix(this, namespace);\n      }\n      case NODE_TYPE.DOCUMENT_NODE: {\n        return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n      }\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n        return null;\n      }\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n      }\n      default: {\n        return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n      }\n    }\n  }\n\n  lookupNamespaceURI(prefix) {\n    if (prefix === \"\") {\n      prefix = null;\n    }\n\n    return locateNamespace(this, prefix);\n  }\n\n  isDefaultNamespace(namespace) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    const defaultNamespace = locateNamespace(this, null);\n    return defaultNamespace === namespace;\n  }\n\n  contains(other) {\n    if (other === null) {\n      return false;\n    } else if (this === other) {\n      return true;\n    }\n    return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n  isEqualNode(node) {\n    if (node === null) {\n      return false;\n    }\n\n    // Fast-path, not in the spec\n    if (this === node) {\n      return true;\n    }\n\n    return nodeEquals(this, node);\n  }\n\n  isSameNode(node) {\n    if (this === node) {\n      return true;\n    }\n\n    return false;\n  }\n\n  cloneNode(deep) {\n    deep = Boolean(deep);\n\n    return clone(this, undefined, deep);\n  }\n\n  get nodeValue() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._value;\n      }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        return this._data;\n      }\n      default: {\n        return null;\n      }\n    }\n  }\n\n  set nodeValue(value) {\n    if (value === null) {\n      value = \"\";\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        attributes.setAnExistingAttributeValue(this, value);\n        break;\n      }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        this.replaceData(0, this.length, value);\n        break;\n      }\n    }\n  }\n\n  get textContent() {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE: {\n        let text = \"\";\n        for (const child of domSymbolTree.treeIterator(this)) {\n          if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n            text += child.nodeValue;\n          }\n        }\n        return text;\n      }\n\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._value;\n      }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        return this._data;\n      }\n\n      default: {\n        return null;\n      }\n    }\n  }\n\n  set textContent(value) {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE: {\n        let child = domSymbolTree.firstChild(this);\n        while (child) {\n          this.removeChild(child);\n          child = domSymbolTree.firstChild(this);\n        }\n\n        if (value !== null && value !== \"\") {\n          this.appendChild(this._ownerDocument.createTextNode(value));\n        }\n\n        break;\n      }\n\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        attributes.setAnExistingAttributeValue(this, value);\n        break;\n      }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        this.replaceData(0, this.length, value);\n        break;\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: NodeImpl\n};\n"]},"metadata":{},"sourceType":"script"}