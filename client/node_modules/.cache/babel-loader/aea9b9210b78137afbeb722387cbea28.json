{"ast":null,"code":"\"use strict\";\n\nconst util = require(\"util\");\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst ErrorEvent = require(\"../generated/ErrorEvent\");\n\nconst errorReportingMode = Symbol(\"error reporting mode\"); // https://html.spec.whatwg.org/multipage/webappapis.html#report-the-error\n// Omits script parameter and any check for muted errors.\n// Takes target as an EventTarget impl.\n// Takes error object, message, and location as params, unlike the spec.\n// Returns whether the event was handled or not.\n\nfunction reportAnError(line, col, target, errorObject, message, location) {\n  if (target[errorReportingMode]) {\n    return false;\n  }\n\n  target[errorReportingMode] = true; // TODO Events: use constructor directly, once they are no longer tied to a window.\n\n  const event = ErrorEvent.createImpl([\"error\", {\n    bubbles: false,\n    cancelable: true,\n    message,\n    filename: location,\n    lineno: line,\n    colno: col,\n    error: errorObject\n  }]);\n\n  try {\n    target.dispatchEvent(event);\n  } finally {\n    target[errorReportingMode] = false;\n    return event.defaultPrevented;\n  }\n}\n\nmodule.exports = function reportException(window, error, filenameHint) {\n  // This function will give good results on real Error objects with stacks; poor ones otherwise\n  const stack = error && error.stack;\n  const lines = stack && stack.split(\"\\n\"); // Find the first line that matches; important for multi-line messages\n\n  let pieces;\n\n  if (lines) {\n    for (let i = 1; i < lines.length && !pieces; ++i) {\n      pieces = lines[i].match(/at (?:(.+)\\s+)?\\(?(?:(.+?):(\\d+):(\\d+)|([^)]+))\\)?/);\n    }\n  }\n\n  const fileName = pieces && pieces[2] || filenameHint || window._document.URL;\n  const lineNumber = pieces && parseInt(pieces[3]) || 0;\n  const columnNumber = pieces && parseInt(pieces[4]) || 0;\n  const windowImpl = idlUtils.implForWrapper(window);\n  const handled = reportAnError(lineNumber, columnNumber, windowImpl, error, error.message, fileName);\n\n  if (!handled) {\n    const errorString = shouldBeDisplayedAsError(error) ? `[${error.name}: ${error.message}]` : util.inspect(error);\n    const jsdomError = new Error(`Uncaught ${errorString}`);\n    jsdomError.detail = error;\n    jsdomError.type = \"unhandled exception\";\n\n    window._virtualConsole.emit(\"jsdomError\", jsdomError);\n  }\n};\n\nfunction shouldBeDisplayedAsError(x) {\n  return x.name && x.message !== undefined && x.stack;\n}","map":{"version":3,"sources":["/Users/krispol/Desktop/invoice/invoice-with-session/client/node_modules/jsdom/lib/jsdom/living/helpers/runtime-script-errors.js"],"names":["util","require","idlUtils","ErrorEvent","errorReportingMode","Symbol","reportAnError","line","col","target","errorObject","message","location","event","createImpl","bubbles","cancelable","filename","lineno","colno","error","dispatchEvent","defaultPrevented","module","exports","reportException","window","filenameHint","stack","lines","split","pieces","i","length","match","fileName","_document","URL","lineNumber","parseInt","columnNumber","windowImpl","implForWrapper","handled","errorString","shouldBeDisplayedAsError","name","inspect","jsdomError","Error","detail","type","_virtualConsole","emit","x","undefined"],"mappings":"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","sourcesContent":["\"use strict\";\nconst util = require(\"util\");\nconst idlUtils = require(\"../generated/utils\");\nconst ErrorEvent = require(\"../generated/ErrorEvent\");\n\nconst errorReportingMode = Symbol(\"error reporting mode\");\n\n// https://html.spec.whatwg.org/multipage/webappapis.html#report-the-error\n// Omits script parameter and any check for muted errors.\n// Takes target as an EventTarget impl.\n// Takes error object, message, and location as params, unlike the spec.\n// Returns whether the event was handled or not.\nfunction reportAnError(line, col, target, errorObject, message, location) {\n  if (target[errorReportingMode]) {\n    return false;\n  }\n\n  target[errorReportingMode] = true;\n\n  // TODO Events: use constructor directly, once they are no longer tied to a window.\n  const event = ErrorEvent.createImpl([\n    \"error\",\n    {\n      bubbles: false,\n      cancelable: true,\n      message,\n      filename: location,\n      lineno: line,\n      colno: col,\n      error: errorObject\n    }\n  ]);\n\n  try {\n    target.dispatchEvent(event);\n  } finally {\n    target[errorReportingMode] = false;\n    return event.defaultPrevented;\n  }\n}\n\nmodule.exports = function reportException(window, error, filenameHint) {\n  // This function will give good results on real Error objects with stacks; poor ones otherwise\n\n  const stack = error && error.stack;\n  const lines = stack && stack.split(\"\\n\");\n\n  // Find the first line that matches; important for multi-line messages\n  let pieces;\n  if (lines) {\n    for (let i = 1; i < lines.length && !pieces; ++i) {\n      pieces = lines[i].match(/at (?:(.+)\\s+)?\\(?(?:(.+?):(\\d+):(\\d+)|([^)]+))\\)?/);\n    }\n  }\n\n  const fileName = (pieces && pieces[2]) || filenameHint || window._document.URL;\n  const lineNumber = (pieces && parseInt(pieces[3])) || 0;\n  const columnNumber = (pieces && parseInt(pieces[4])) || 0;\n\n  const windowImpl = idlUtils.implForWrapper(window);\n\n  const handled = reportAnError(lineNumber, columnNumber, windowImpl, error, error.message, fileName);\n\n  if (!handled) {\n    const errorString = shouldBeDisplayedAsError(error) ? `[${error.name}: ${error.message}]` : util.inspect(error);\n    const jsdomError = new Error(`Uncaught ${errorString}`);\n    jsdomError.detail = error;\n    jsdomError.type = \"unhandled exception\";\n\n    window._virtualConsole.emit(\"jsdomError\", jsdomError);\n  }\n};\n\nfunction shouldBeDisplayedAsError(x) {\n  return x.name && x.message !== undefined && x.stack;\n}\n"]},"metadata":{},"sourceType":"script"}