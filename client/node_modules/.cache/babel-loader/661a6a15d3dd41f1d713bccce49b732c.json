{"ast":null,"code":"\"use strict\";\n\nconst DOMException = require(\"domexception\");\n\nconst reportException = require(\"../helpers/runtime-script-errors\");\n\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst Event = require(\"../generated/Event\").interface;\n\nclass EventTargetImpl {\n  constructor() {\n    this._eventListeners = Object.create(null);\n  }\n\n  addEventListener(type, callback, options) {\n    // webidl2js currently can't handle neither optional arguments nor callback interfaces\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\", \"once\"]);\n\n    if (callback === null) {\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n\n      if (listener.options.capture === options.capture && listener.callback === callback) {\n        return;\n      }\n    }\n\n    this._eventListeners[type].push({\n      callback,\n      options\n    });\n  }\n\n  removeEventListener(type, callback, options) {\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n    if (callback === null) {\n      // Optimization, not in the spec.\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      return;\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n\n      if (listener.callback === callback && listener.options.capture === options.capture) {\n        this._eventListeners[type].splice(i, 1);\n\n        break;\n      }\n    }\n  }\n\n  dispatchEvent(eventImpl) {\n    if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n      throw new DOMException(\"Tried to dispatch an uninitialized event\", \"InvalidStateError\");\n    }\n\n    if (eventImpl.eventPhase !== Event.NONE) {\n      throw new DOMException(\"Tried to dispatch a dispatching event\", \"InvalidStateError\");\n    }\n\n    eventImpl.isTrusted = false;\n    return this._dispatch(eventImpl);\n  }\n\n  _dispatch(eventImpl, targetOverride) {\n    eventImpl._dispatchFlag = true;\n    eventImpl.target = targetOverride || this;\n    const eventPath = [];\n    let {\n      target\n    } = eventImpl;\n    let targetParent = domSymbolTree.parent(target);\n\n    while (targetParent) {\n      eventPath.push(targetParent);\n      target = targetParent;\n      targetParent = domSymbolTree.parent(targetParent);\n    }\n\n    if (eventImpl.type !== \"load\" && target._defaultView) {\n      // https://html.spec.whatwg.org/#events-and-the-window-object\n      eventPath.push(idlUtils.implForWrapper(target._defaultView));\n    }\n\n    eventImpl.eventPhase = Event.CAPTURING_PHASE;\n\n    for (let i = eventPath.length - 1; i >= 0; --i) {\n      if (eventImpl._stopPropagationFlag) {\n        break;\n      }\n\n      const object = eventPath[i];\n      const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n\n      const eventListeners = objectImpl._eventListeners[eventImpl.type];\n      invokeEventListeners(eventListeners, object, eventImpl);\n    }\n\n    eventImpl.eventPhase = Event.AT_TARGET;\n\n    if (!eventImpl._stopPropagationFlag) {\n      if (this._eventListeners[eventImpl.type]) {\n        const eventListeners = this._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, eventImpl.target, eventImpl);\n      }\n    }\n\n    if (eventImpl.bubbles) {\n      eventImpl.eventPhase = Event.BUBBLING_PHASE;\n\n      for (let i = 0; i < eventPath.length; ++i) {\n        if (eventImpl._stopPropagationFlag) {\n          break;\n        }\n\n        const object = eventPath[i];\n        const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n\n        const eventListeners = objectImpl._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, object, eventImpl);\n      }\n    }\n\n    eventImpl._dispatchFlag = false;\n    eventImpl._stopPropagationFlag = false;\n    eventImpl._stopImmediatePropagationFlag = false;\n    eventImpl.eventPhase = Event.NONE;\n    eventImpl.currentTarget = null;\n    return !eventImpl._canceledFlag;\n  }\n\n}\n\nmodule.exports = {\n  implementation: EventTargetImpl\n};\n\nfunction invokeEventListeners(listeners, target, eventImpl) {\n  const wrapper = idlUtils.wrapperForImpl(target);\n  const document = target._ownerDocument || wrapper && (wrapper._document || wrapper._ownerDocument); // Will be falsy for windows that have closed\n\n  if (!document) {\n    return;\n  } // workaround for events emitted on window (window-proxy)\n  // the wrapper is the root window instance, but we only want to expose the vm proxy at all times\n\n\n  if (wrapper._document && wrapper.constructor.name === \"Window\") {\n    target = idlUtils.implForWrapper(wrapper._document)._defaultView;\n  }\n\n  eventImpl.currentTarget = target;\n\n  if (!listeners) {\n    return;\n  }\n\n  const handlers = listeners.slice();\n\n  for (let i = 0; i < handlers.length; ++i) {\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return;\n    }\n\n    const listener = handlers[i];\n    const {\n      capture,\n      once\n      /* , passive */\n\n    } = listener.options;\n\n    if (listeners.indexOf(listener) === -1 || eventImpl.eventPhase === Event.CAPTURING_PHASE && !capture || eventImpl.eventPhase === Event.BUBBLING_PHASE && capture) {\n      continue;\n    }\n\n    if (once) {\n      listeners.splice(listeners.indexOf(listener), 1);\n    }\n\n    try {\n      if (typeof listener.callback === \"object\") {\n        if (typeof listener.callback.handleEvent === \"function\") {\n          listener.callback.handleEvent(idlUtils.wrapperForImpl(eventImpl));\n        }\n      } else {\n        listener.callback.call(idlUtils.wrapperForImpl(eventImpl.currentTarget), idlUtils.wrapperForImpl(eventImpl));\n      }\n    } catch (e) {\n      let window = null;\n\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by XHR and some other non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n\n      if (window) {\n        reportException(window, e);\n      } // Errors in window-less documents just get swallowed... can you think of anything better?\n\n    }\n  }\n}\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\n\n\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {}; // no need to go further here\n\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  } // non objects options so we typecast its value as \"capture\" value\n\n\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options); // at this point we don't need to loop the \"capture\" key anymore\n\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  return returnValue;\n}","map":{"version":3,"sources":["/Users/krispol/Desktop/invoice/invoice-with-session/client/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js"],"names":["DOMException","require","reportException","domSymbolTree","idlUtils","Event","interface","EventTargetImpl","constructor","_eventListeners","Object","create","addEventListener","type","callback","options","undefined","TypeError","normalizeEventHandlerOptions","i","length","listener","capture","push","removeEventListener","splice","dispatchEvent","eventImpl","_dispatchFlag","_initializedFlag","eventPhase","NONE","isTrusted","_dispatch","targetOverride","target","eventPath","targetParent","parent","_defaultView","implForWrapper","CAPTURING_PHASE","_stopPropagationFlag","object","objectImpl","eventListeners","invokeEventListeners","AT_TARGET","bubbles","BUBBLING_PHASE","_stopImmediatePropagationFlag","currentTarget","_canceledFlag","module","exports","implementation","listeners","wrapper","wrapperForImpl","document","_ownerDocument","_document","name","handlers","slice","once","indexOf","handleEvent","call","e","window","defaultBoolKeys","returnValue","Boolean","filter","k","key"],"mappings":"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","sourcesContent":["\"use strict\";\nconst DOMException = require(\"domexception\");\nconst reportException = require(\"../helpers/runtime-script-errors\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst idlUtils = require(\"../generated/utils\");\n\nconst Event = require(\"../generated/Event\").interface;\n\nclass EventTargetImpl {\n  constructor() {\n    this._eventListeners = Object.create(null);\n  }\n\n  addEventListener(type, callback, options) {\n    // webidl2js currently can't handle neither optional arguments nor callback interfaces\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\", \"once\"]);\n\n    if (callback === null) {\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.options.capture === options.capture && listener.callback === callback) {\n        return;\n      }\n    }\n\n    this._eventListeners[type].push({\n      callback,\n      options\n    });\n  }\n\n  removeEventListener(type, callback, options) {\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n    if (callback === null) {\n      // Optimization, not in the spec.\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      return;\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.callback === callback && listener.options.capture === options.capture) {\n        this._eventListeners[type].splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  dispatchEvent(eventImpl) {\n    if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n      throw new DOMException(\"Tried to dispatch an uninitialized event\", \"InvalidStateError\");\n    }\n    if (eventImpl.eventPhase !== Event.NONE) {\n      throw new DOMException(\"Tried to dispatch a dispatching event\", \"InvalidStateError\");\n    }\n\n    eventImpl.isTrusted = false;\n\n    return this._dispatch(eventImpl);\n  }\n\n  _dispatch(eventImpl, targetOverride) {\n    eventImpl._dispatchFlag = true;\n    eventImpl.target = targetOverride || this;\n\n    const eventPath = [];\n    let { target } = eventImpl;\n    let targetParent = domSymbolTree.parent(target);\n    while (targetParent) {\n      eventPath.push(targetParent);\n      target = targetParent;\n      targetParent = domSymbolTree.parent(targetParent);\n    }\n    if (eventImpl.type !== \"load\" && target._defaultView) {\n      // https://html.spec.whatwg.org/#events-and-the-window-object\n      eventPath.push(idlUtils.implForWrapper(target._defaultView));\n    }\n\n    eventImpl.eventPhase = Event.CAPTURING_PHASE;\n    for (let i = eventPath.length - 1; i >= 0; --i) {\n      if (eventImpl._stopPropagationFlag) {\n        break;\n      }\n\n      const object = eventPath[i];\n      const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n      const eventListeners = objectImpl._eventListeners[eventImpl.type];\n      invokeEventListeners(eventListeners, object, eventImpl);\n    }\n\n    eventImpl.eventPhase = Event.AT_TARGET;\n\n    if (!eventImpl._stopPropagationFlag) {\n      if (this._eventListeners[eventImpl.type]) {\n        const eventListeners = this._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, eventImpl.target, eventImpl);\n      }\n    }\n\n    if (eventImpl.bubbles) {\n      eventImpl.eventPhase = Event.BUBBLING_PHASE;\n      for (let i = 0; i < eventPath.length; ++i) {\n        if (eventImpl._stopPropagationFlag) {\n          break;\n        }\n\n        const object = eventPath[i];\n        const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n        const eventListeners = objectImpl._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, object, eventImpl);\n      }\n    }\n\n    eventImpl._dispatchFlag = false;\n    eventImpl._stopPropagationFlag = false;\n    eventImpl._stopImmediatePropagationFlag = false;\n    eventImpl.eventPhase = Event.NONE;\n    eventImpl.currentTarget = null;\n    return !eventImpl._canceledFlag;\n  }\n}\n\nmodule.exports = {\n  implementation: EventTargetImpl\n};\n\nfunction invokeEventListeners(listeners, target, eventImpl) {\n  const wrapper = idlUtils.wrapperForImpl(target);\n  const document = target._ownerDocument || (wrapper && (wrapper._document || wrapper._ownerDocument));\n  // Will be falsy for windows that have closed\n  if (!document) {\n    return;\n  }\n\n  // workaround for events emitted on window (window-proxy)\n  // the wrapper is the root window instance, but we only want to expose the vm proxy at all times\n  if (wrapper._document && wrapper.constructor.name === \"Window\") {\n    target = idlUtils.implForWrapper(wrapper._document)._defaultView;\n  }\n  eventImpl.currentTarget = target;\n  if (!listeners) {\n    return;\n  }\n\n  const handlers = listeners.slice();\n  for (let i = 0; i < handlers.length; ++i) {\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return;\n    }\n\n    const listener = handlers[i];\n    const { capture, once/* , passive */ } = listener.options;\n\n    if (listeners.indexOf(listener) === -1 ||\n        (eventImpl.eventPhase === Event.CAPTURING_PHASE && !capture) ||\n        (eventImpl.eventPhase === Event.BUBBLING_PHASE && capture)) {\n      continue;\n    }\n\n    if (once) {\n      listeners.splice(listeners.indexOf(listener), 1);\n    }\n\n    try {\n      if (typeof listener.callback === \"object\") {\n        if (typeof listener.callback.handleEvent === \"function\") {\n          listener.callback.handleEvent(idlUtils.wrapperForImpl(eventImpl));\n        }\n      } else {\n        listener.callback.call(idlUtils.wrapperForImpl(eventImpl.currentTarget), idlUtils.wrapperForImpl(eventImpl));\n      }\n    } catch (e) {\n      let window = null;\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by XHR and some other non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n\n      if (window) {\n        reportException(window, e);\n      }\n      // Errors in window-less documents just get swallowed... can you think of anything better?\n    }\n  }\n}\n\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {};\n\n  // no need to go further here\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  }\n\n  // non objects options so we typecast its value as \"capture\" value\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options);\n    // at this point we don't need to loop the \"capture\" key anymore\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  return returnValue;\n}\n"]},"metadata":{},"sourceType":"script"}