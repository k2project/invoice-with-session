{"ast":null,"code":"\"use strict\";\n\nconst DocumentType = require(\"../living/generated/DocumentType\");\n\nconst DocumentFragment = require(\"../living/generated/DocumentFragment\");\n\nconst Text = require(\"../living/generated/Text\");\n\nconst Comment = require(\"../living/generated/Comment\");\n\nconst attributes = require(\"../living/attributes\");\n\nconst nodeTypes = require(\"../living/node-type\");\n\nconst serializationAdapter = require(\"./parse5-adapter-serialization\");\n\nmodule.exports = class JSDOMParse5Adapter {\n  constructor(documentImpl) {\n    this._documentImpl = documentImpl;\n  }\n\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n\n  createDocumentFragment() {\n    return DocumentFragment.createImpl([], {\n      ownerDocument: this._documentImpl\n    });\n  }\n\n  createElement(localName, namespace, attrs) {\n    const element = this._documentImpl._createElementWithCorrectElementInterface(localName, namespace);\n\n    element._namespaceURI = namespace;\n    this.adoptAttributes(element, attrs);\n\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n\n    return element;\n  }\n\n  createCommentNode(data) {\n    return Comment.createImpl([], {\n      data,\n      ownerDocument: this._documentImpl\n    });\n  }\n\n  appendChild(parentNode, newNode) {\n    parentNode.appendChild(newNode);\n  }\n\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  setTemplateContent(templateElement, contentFragment) {\n    templateElement._templateContents = contentFragment;\n  }\n\n  setDocumentType(document, name, publicId, systemId) {\n    // parse5 sometimes gives us these as null.\n    if (name === null) {\n      name = \"\";\n    }\n\n    if (publicId === null) {\n      publicId = \"\";\n    }\n\n    if (systemId === null) {\n      systemId = \"\";\n    }\n\n    const documentType = DocumentType.createImpl([], {\n      name,\n      publicId,\n      systemId,\n      ownerDocument: this._documentImpl\n    });\n    document.appendChild(documentType);\n  }\n\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n\n  detachNode(node) {\n    node.remove();\n  }\n\n  insertText(parentNode, text) {\n    const {\n      lastChild\n    } = parentNode;\n\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const textNode = Text.createImpl([], {\n        data: text,\n        ownerDocument: this._documentImpl\n      });\n      parentNode.appendChild(textNode);\n    }\n  }\n\n  insertTextBefore(parentNode, text, referenceNode) {\n    const {\n      previousSibling\n    } = referenceNode;\n\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const textNode = Text.createImpl([], {\n        data: text,\n        ownerDocument: this._documentImpl\n      });\n      parentNode.insertBefore(textNode, referenceNode);\n    }\n  }\n\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n\n};\nObject.assign(module.exports.prototype, serializationAdapter);","map":{"version":3,"sources":["/Users/krispol/Desktop/invoice/invoice-with-session/client/node_modules/jsdom/lib/jsdom/browser/parse5-adapter-parsing.js"],"names":["DocumentType","require","DocumentFragment","Text","Comment","attributes","nodeTypes","serializationAdapter","module","exports","JSDOMParse5Adapter","constructor","documentImpl","_documentImpl","createDocument","createDocumentFragment","createImpl","ownerDocument","createElement","localName","namespace","attrs","element","_createElementWithCorrectElementInterface","_namespaceURI","adoptAttributes","_parserInserted","createCommentNode","data","appendChild","parentNode","newNode","insertBefore","referenceNode","setTemplateContent","templateElement","contentFragment","_templateContents","setDocumentType","document","name","publicId","systemId","documentType","setDocumentMode","mode","_mode","detachNode","node","remove","insertText","text","lastChild","nodeType","TEXT_NODE","textNode","insertTextBefore","previousSibling","attr","prefix","setAttributeValue","value","Object","assign","prototype"],"mappings":"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","sourcesContent":["\"use strict\";\nconst DocumentType = require(\"../living/generated/DocumentType\");\nconst DocumentFragment = require(\"../living/generated/DocumentFragment\");\nconst Text = require(\"../living/generated/Text\");\nconst Comment = require(\"../living/generated/Comment\");\nconst attributes = require(\"../living/attributes\");\nconst nodeTypes = require(\"../living/node-type\");\nconst serializationAdapter = require(\"./parse5-adapter-serialization\");\n\nmodule.exports = class JSDOMParse5Adapter {\n  constructor(documentImpl) {\n    this._documentImpl = documentImpl;\n  }\n\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n\n  createDocumentFragment() {\n    return DocumentFragment.createImpl([], { ownerDocument: this._documentImpl });\n  }\n\n  createElement(localName, namespace, attrs) {\n    const element = this._documentImpl._createElementWithCorrectElementInterface(localName, namespace);\n    element._namespaceURI = namespace;\n    this.adoptAttributes(element, attrs);\n\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n\n    return element;\n  }\n\n  createCommentNode(data) {\n    return Comment.createImpl([], { data, ownerDocument: this._documentImpl });\n  }\n\n  appendChild(parentNode, newNode) {\n    parentNode.appendChild(newNode);\n  }\n\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  setTemplateContent(templateElement, contentFragment) {\n    templateElement._templateContents = contentFragment;\n  }\n\n  setDocumentType(document, name, publicId, systemId) {\n    // parse5 sometimes gives us these as null.\n    if (name === null) {\n      name = \"\";\n    }\n    if (publicId === null) {\n      publicId = \"\";\n    }\n    if (systemId === null) {\n      systemId = \"\";\n    }\n\n    const documentType = DocumentType.createImpl([], { name, publicId, systemId, ownerDocument: this._documentImpl });\n    document.appendChild(documentType);\n  }\n\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n\n  detachNode(node) {\n    node.remove();\n  }\n\n  insertText(parentNode, text) {\n    const { lastChild } = parentNode;\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const textNode = Text.createImpl([], { data: text, ownerDocument: this._documentImpl });\n\n      parentNode.appendChild(textNode);\n    }\n  }\n\n  insertTextBefore(parentNode, text, referenceNode) {\n    const { previousSibling } = referenceNode;\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const textNode = Text.createImpl([], { data: text, ownerDocument: this._documentImpl });\n\n      parentNode.insertBefore(textNode, referenceNode);\n    }\n  }\n\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n};\n\nObject.assign(module.exports.prototype, serializationAdapter);\n"]},"metadata":{},"sourceType":"script"}