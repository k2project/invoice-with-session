{"ast":null,"code":"\"use strict\"; // Returns \"Type(value) is Object\" in ES terminology.\n\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null || typeof value === \"function\";\n}\n\nfunction getReferenceToBytes(bufferSource) {\n  // Node.js' Buffer does not allow subclassing for now, so we can get away with a prototype object check for perf.\n  if (Object.getPrototypeOf(bufferSource) === Buffer.prototype) {\n    return bufferSource;\n  }\n\n  if (bufferSource instanceof ArrayBuffer) {\n    return Buffer.from(bufferSource);\n  }\n\n  return Buffer.from(bufferSource.buffer, bufferSource.byteOffset, bufferSource.byteLength);\n}\n\nfunction getCopyToBytes(bufferSource) {\n  return Buffer.from(getReferenceToBytes(bufferSource));\n}\n\nfunction mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n\n  for (let i = 0; i < keys.length; ++i) {\n    if (keys[i] in target) {\n      continue;\n    }\n\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n}\n\nconst wrapperSymbol = Symbol(\"wrapper\");\nconst implSymbol = Symbol(\"impl\");\nconst sameObjectCaches = Symbol(\"SameObject caches\");\n\nfunction getSameObject(wrapper, prop, creator) {\n  if (!wrapper[sameObjectCaches]) {\n    wrapper[sameObjectCaches] = Object.create(null);\n  }\n\n  if (prop in wrapper[sameObjectCaches]) {\n    return wrapper[sameObjectCaches][prop];\n  }\n\n  wrapper[sameObjectCaches][prop] = creator();\n  return wrapper[sameObjectCaches][prop];\n}\n\nfunction wrapperForImpl(impl) {\n  return impl ? impl[wrapperSymbol] : null;\n}\n\nfunction implForWrapper(wrapper) {\n  return wrapper ? wrapper[implSymbol] : null;\n}\n\nfunction tryWrapperForImpl(impl) {\n  const wrapper = wrapperForImpl(impl);\n  return wrapper ? wrapper : impl;\n}\n\nfunction tryImplForWrapper(wrapper) {\n  const impl = implForWrapper(wrapper);\n  return impl ? impl : wrapper;\n}\n\nconst iterInternalSymbol = Symbol(\"internal\");\nconst IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\nmodule.exports = exports = {\n  isObject,\n  getReferenceToBytes,\n  getCopyToBytes,\n  mixin,\n  wrapperSymbol,\n  implSymbol,\n  getSameObject,\n  wrapperForImpl,\n  implForWrapper,\n  tryWrapperForImpl,\n  tryImplForWrapper,\n  iterInternalSymbol,\n  IteratorPrototype\n};","map":{"version":3,"sources":["/Users/krispol/Desktop/invoice/invoice-with-session/client/node_modules/domexception/lib/utils.js"],"names":["isObject","value","getReferenceToBytes","bufferSource","Object","getPrototypeOf","Buffer","prototype","ArrayBuffer","from","buffer","byteOffset","byteLength","getCopyToBytes","mixin","target","source","keys","getOwnPropertyNames","i","length","defineProperty","getOwnPropertyDescriptor","wrapperSymbol","Symbol","implSymbol","sameObjectCaches","getSameObject","wrapper","prop","creator","create","wrapperForImpl","impl","implForWrapper","tryWrapperForImpl","tryImplForWrapper","iterInternalSymbol","IteratorPrototype","iterator","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// Returns \"Type(value) is Object\" in ES terminology.\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null || typeof value === \"function\";\n}\n\nfunction getReferenceToBytes(bufferSource) {\n  // Node.js' Buffer does not allow subclassing for now, so we can get away with a prototype object check for perf.\n  if (Object.getPrototypeOf(bufferSource) === Buffer.prototype) {\n    return bufferSource;\n  }\n  if (bufferSource instanceof ArrayBuffer) {\n    return Buffer.from(bufferSource);\n  }\n  return Buffer.from(bufferSource.buffer, bufferSource.byteOffset, bufferSource.byteLength);\n}\n\nfunction getCopyToBytes(bufferSource) {\n  return Buffer.from(getReferenceToBytes(bufferSource));\n}\n\nfunction mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n  for (let i = 0; i < keys.length; ++i) {\n    if (keys[i] in target) {\n      continue;\n    }\n\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n}\n\nconst wrapperSymbol = Symbol(\"wrapper\");\nconst implSymbol = Symbol(\"impl\");\nconst sameObjectCaches = Symbol(\"SameObject caches\");\n\nfunction getSameObject(wrapper, prop, creator) {\n  if (!wrapper[sameObjectCaches]) {\n    wrapper[sameObjectCaches] = Object.create(null);\n  }\n\n  if (prop in wrapper[sameObjectCaches]) {\n    return wrapper[sameObjectCaches][prop];\n  }\n\n  wrapper[sameObjectCaches][prop] = creator();\n  return wrapper[sameObjectCaches][prop];\n}\n\nfunction wrapperForImpl(impl) {\n  return impl ? impl[wrapperSymbol] : null;\n}\n\nfunction implForWrapper(wrapper) {\n  return wrapper ? wrapper[implSymbol] : null;\n}\n\nfunction tryWrapperForImpl(impl) {\n  const wrapper = wrapperForImpl(impl);\n  return wrapper ? wrapper : impl;\n}\n\nfunction tryImplForWrapper(wrapper) {\n  const impl = implForWrapper(wrapper);\n  return impl ? impl : wrapper;\n}\n\nconst iterInternalSymbol = Symbol(\"internal\");\nconst IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n\nmodule.exports = exports = {\n  isObject,\n  getReferenceToBytes,\n  getCopyToBytes,\n  mixin,\n  wrapperSymbol,\n  implSymbol,\n  getSameObject,\n  wrapperForImpl,\n  implForWrapper,\n  tryWrapperForImpl,\n  tryImplForWrapper,\n  iterInternalSymbol,\n  IteratorPrototype\n};\n"]},"metadata":{},"sourceType":"script"}