{"ast":null,"code":"\"use strict\";\n\nconst DOMException = require(\"domexception\");\n\nconst {\n  filter,\n  FILTER_ACCEPT,\n  FILTER_REJECT,\n  FILTER_SKIP\n} = require(\"./helpers\");\n\nconst FIRST = false;\nconst LAST = true;\nconst NEXT = false;\nconst PREVIOUS = true;\nexports.implementation = class TreeWalkerImpl {\n  constructor(args, privateData) {\n    this._active = false;\n    this.root = privateData.root;\n    this.whatToShow = privateData.whatToShow;\n    this.filter = privateData.filter;\n    this.currentNode = this.root;\n  }\n\n  get currentNode() {\n    return this._currentNode;\n  }\n\n  set currentNode(node) {\n    if (node === null) {\n      throw new DOMException(\"Cannot set currentNode to null\", \"NotSupportedError\");\n    }\n\n    this._currentNode = node;\n  }\n\n  parentNode() {\n    let node = this._currentNode;\n\n    while (node !== null && node !== this.root) {\n      node = node.parentNode;\n\n      if (node !== null && filter(this, node) === FILTER_ACCEPT) {\n        return this._currentNode = node;\n      }\n    }\n\n    return null;\n  }\n\n  firstChild() {\n    return this._traverseChildren(FIRST);\n  }\n\n  lastChild() {\n    return this._traverseChildren(LAST);\n  }\n\n  previousSibling() {\n    return this._traverseSiblings(PREVIOUS);\n  }\n\n  nextSibling() {\n    return this._traverseSiblings(NEXT);\n  }\n\n  previousNode() {\n    let node = this._currentNode;\n\n    while (node !== this.root) {\n      let sibling = node.previousSibling;\n\n      while (sibling !== null) {\n        node = sibling;\n        let result = filter(this, node);\n\n        while (result !== FILTER_REJECT && node.hasChildNodes()) {\n          node = node.lastChild;\n          result = filter(this, node);\n        }\n\n        if (result === FILTER_ACCEPT) {\n          return this._currentNode = node;\n        }\n\n        sibling = node.previousSibling;\n      }\n\n      if (node === this.root || node.parentNode === null) {\n        return null;\n      }\n\n      node = node.parentNode;\n\n      if (filter(this, node) === FILTER_ACCEPT) {\n        return this._currentNode = node;\n      }\n    }\n\n    return null;\n  }\n\n  nextNode() {\n    let node = this._currentNode;\n    let result = FILTER_ACCEPT;\n\n    for (;;) {\n      while (result !== FILTER_REJECT && node.hasChildNodes()) {\n        node = node.firstChild;\n        result = filter(this, node);\n\n        if (result === FILTER_ACCEPT) {\n          return this._currentNode = node;\n        }\n      }\n\n      do {\n        if (node === this.root) {\n          return null;\n        }\n\n        const sibling = node.nextSibling;\n\n        if (sibling !== null) {\n          node = sibling;\n          break;\n        }\n\n        node = node.parentNode;\n      } while (node !== null);\n\n      if (node === null) {\n        return null;\n      }\n\n      result = filter(this, node);\n\n      if (result === FILTER_ACCEPT) {\n        return this._currentNode = node;\n      }\n    }\n  }\n\n  _traverseChildren(type) {\n    let node = this._currentNode;\n    node = type === FIRST ? node.firstChild : node.lastChild;\n\n    if (node === null) {\n      return null;\n    }\n\n    main: for (;;) {\n      const result = filter(this, node);\n\n      if (result === FILTER_ACCEPT) {\n        return this._currentNode = node;\n      }\n\n      if (result === FILTER_SKIP) {\n        const child = type === FIRST ? node.firstChild : node.lastChild;\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      for (;;) {\n        const sibling = type === FIRST ? node.nextSibling : node.previousSibling;\n\n        if (sibling !== null) {\n          node = sibling;\n          continue main;\n        }\n\n        const parent = node.parentNode;\n\n        if (parent === null || parent === this.root || parent === this._currentNode) {\n          return null;\n        }\n\n        node = parent;\n      }\n    }\n  }\n\n  _traverseSiblings(type) {\n    let node = this._currentNode;\n\n    if (node === this.root) {\n      return null;\n    }\n\n    for (;;) {\n      let sibling = type === NEXT ? node.nextSibling : node.previousSibling;\n\n      while (sibling !== null) {\n        node = sibling;\n        const result = filter(this, node);\n\n        if (result === FILTER_ACCEPT) {\n          return this._currentNode = node;\n        }\n\n        sibling = type === NEXT ? node.firstChild : node.lastChild;\n\n        if (result === FILTER_REJECT || sibling === null) {\n          sibling = type === NEXT ? node.nextSibling : node.previousSibling;\n        }\n      }\n\n      node = node.parentNode;\n\n      if (node === null || node === this.root) {\n        return null;\n      }\n\n      if (filter(this, node) === FILTER_ACCEPT) {\n        return null;\n      }\n    }\n  }\n\n};","map":{"version":3,"sources":["/Users/krispol/Desktop/invoice/invoice-with-session/client/node_modules/jsdom/lib/jsdom/living/traversal/TreeWalker-impl.js"],"names":["DOMException","require","filter","FILTER_ACCEPT","FILTER_REJECT","FILTER_SKIP","FIRST","LAST","NEXT","PREVIOUS","exports","implementation","TreeWalkerImpl","constructor","args","privateData","_active","root","whatToShow","currentNode","_currentNode","node","parentNode","firstChild","_traverseChildren","lastChild","previousSibling","_traverseSiblings","nextSibling","previousNode","sibling","result","hasChildNodes","nextNode","type","main","child","parent"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst DOMException = require(\"domexception\");\nconst { filter, FILTER_ACCEPT, FILTER_REJECT, FILTER_SKIP } = require(\"./helpers\");\n\nconst FIRST = false;\nconst LAST = true;\nconst NEXT = false;\nconst PREVIOUS = true;\n\nexports.implementation = class TreeWalkerImpl {\n  constructor(args, privateData) {\n    this._active = false;\n    this.root = privateData.root;\n    this.whatToShow = privateData.whatToShow;\n    this.filter = privateData.filter;\n\n    this.currentNode = this.root;\n  }\n\n  get currentNode() {\n    return this._currentNode;\n  }\n\n  set currentNode(node) {\n    if (node === null) {\n      throw new DOMException(\"Cannot set currentNode to null\", \"NotSupportedError\");\n    }\n\n    this._currentNode = node;\n  }\n\n  parentNode() {\n    let node = this._currentNode;\n    while (node !== null && node !== this.root) {\n      node = node.parentNode;\n\n      if (node !== null && filter(this, node) === FILTER_ACCEPT) {\n        return (this._currentNode = node);\n      }\n    }\n    return null;\n  }\n\n  firstChild() {\n    return this._traverseChildren(FIRST);\n  }\n\n  lastChild() {\n    return this._traverseChildren(LAST);\n  }\n\n  previousSibling() {\n    return this._traverseSiblings(PREVIOUS);\n  }\n\n  nextSibling() {\n    return this._traverseSiblings(NEXT);\n  }\n\n  previousNode() {\n    let node = this._currentNode;\n\n    while (node !== this.root) {\n      let sibling = node.previousSibling;\n\n      while (sibling !== null) {\n        node = sibling;\n        let result = filter(this, node);\n\n        while (result !== FILTER_REJECT && node.hasChildNodes()) {\n          node = node.lastChild;\n          result = filter(this, node);\n        }\n\n        if (result === FILTER_ACCEPT) {\n          return (this._currentNode = node);\n        }\n\n        sibling = node.previousSibling;\n      }\n\n      if (node === this.root || node.parentNode === null) {\n        return null;\n      }\n\n      node = node.parentNode;\n\n      if (filter(this, node) === FILTER_ACCEPT) {\n        return (this._currentNode = node);\n      }\n    }\n\n    return null;\n  }\n\n  nextNode() {\n    let node = this._currentNode;\n    let result = FILTER_ACCEPT;\n\n    for (;;) {\n      while (result !== FILTER_REJECT && node.hasChildNodes()) {\n        node = node.firstChild;\n        result = filter(this, node);\n        if (result === FILTER_ACCEPT) {\n          return (this._currentNode = node);\n        }\n      }\n\n      do {\n        if (node === this.root) {\n          return null;\n        }\n\n        const sibling = node.nextSibling;\n\n        if (sibling !== null) {\n          node = sibling;\n          break;\n        }\n\n        node = node.parentNode;\n      } while (node !== null);\n\n      if (node === null) {\n        return null;\n      }\n\n      result = filter(this, node);\n\n      if (result === FILTER_ACCEPT) {\n        return (this._currentNode = node);\n      }\n    }\n  }\n\n  _traverseChildren(type) {\n    let node = this._currentNode;\n    node = type === FIRST ? node.firstChild : node.lastChild;\n\n    if (node === null) {\n      return null;\n    }\n\n    main: for (;;) {\n      const result = filter(this, node);\n\n      if (result === FILTER_ACCEPT) {\n        return (this._currentNode = node);\n      }\n\n      if (result === FILTER_SKIP) {\n        const child = type === FIRST ? node.firstChild : node.lastChild;\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      for (;;) {\n        const sibling = type === FIRST ? node.nextSibling : node.previousSibling;\n\n        if (sibling !== null) {\n          node = sibling;\n          continue main;\n        }\n\n        const parent = node.parentNode;\n\n        if (parent === null || parent === this.root || parent === this._currentNode) {\n          return null;\n        }\n\n        node = parent;\n      }\n    }\n  }\n\n  _traverseSiblings(type) {\n    let node = this._currentNode;\n\n    if (node === this.root) {\n      return null;\n    }\n\n    for (;;) {\n      let sibling = type === NEXT ? node.nextSibling : node.previousSibling;\n\n      while (sibling !== null) {\n        node = sibling;\n        const result = filter(this, node);\n\n        if (result === FILTER_ACCEPT) {\n          return (this._currentNode = node);\n        }\n\n        sibling = type === NEXT ? node.firstChild : node.lastChild;\n\n        if (result === FILTER_REJECT || sibling === null) {\n          sibling = type === NEXT ? node.nextSibling : node.previousSibling;\n        }\n      }\n\n      node = node.parentNode;\n\n      if (node === null || node === this.root) {\n        return null;\n      }\n\n      if (filter(this, node) === FILTER_ACCEPT) {\n        return null;\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}