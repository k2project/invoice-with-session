{"ast":null,"code":"'use strict';\n\nvar INITIAL_STATE = 1;\nvar FAIL_STATE = 0;\n/**\n * A StateMachine represents a deterministic finite automaton.\n * It can perform matches over a sequence of values, similar to a regular expression.\n */\n\nclass StateMachine {\n  constructor(dfa) {\n    this.stateTable = dfa.stateTable;\n    this.accepting = dfa.accepting;\n    this.tags = dfa.tags;\n  }\n  /**\n   * Returns an iterable object that yields pattern matches over the input sequence.\n   * Matches are of the form [startIndex, endIndex, tags].\n   */\n\n\n  match(str) {\n    var self = this;\n    return {\n      *[Symbol.iterator]() {\n        var state = INITIAL_STATE;\n        var startRun = null;\n        var lastAccepting = null;\n        var lastState = null;\n\n        for (var p = 0; p < str.length; p++) {\n          var c = str[p];\n          lastState = state;\n          state = self.stateTable[state][c];\n\n          if (state === FAIL_STATE) {\n            // yield the last match if any\n            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n              yield [startRun, lastAccepting, self.tags[lastState]];\n            } // reset the state as if we started over from the initial state\n\n\n            state = self.stateTable[INITIAL_STATE][c];\n            startRun = null;\n          } // start a run if not in the failure state\n\n\n          if (state !== FAIL_STATE && startRun == null) {\n            startRun = p;\n          } // if accepting, mark the potential match end\n\n\n          if (self.accepting[state]) {\n            lastAccepting = p;\n          } // reset the state to the initial state if we get into the failure state\n\n\n          if (state === FAIL_STATE) {\n            state = INITIAL_STATE;\n          }\n        } // yield the last match if any\n\n\n        if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n          yield [startRun, lastAccepting, self.tags[state]];\n        }\n      }\n\n    };\n  }\n  /**\n   * For each match over the input sequence, action functions matching\n   * the tag definitions in the input pattern are called with the startIndex,\n   * endIndex, and sub-match sequence.\n   */\n\n\n  apply(str, actions) {\n    for (var [start, end, tags] of this.match(str)) {\n      for (var tag of tags) {\n        if (typeof actions[tag] === 'function') {\n          actions[tag](start, end, str.slice(start, end + 1));\n        }\n      }\n    }\n  }\n\n}\n\nmodule.exports = StateMachine;","map":{"version":3,"sources":["src/StateMachine.js"],"names":["INITIAL_STATE","FAIL_STATE","constructor","dfa","match","self","Symbol","state","startRun","lastAccepting","lastState","p","str","c","apply","actions","end"],"mappings":";;AAAA,IAAMA,aAAa,GAAnB,CAAA;AACA,IAAMC,UAAU,GAAhB,CAAA;;;;;;AAMe,MAAA,YAAA,CAAmB;AAChCC,EAAAA,WAAW,CAAA,GAAA,EAAM;SACf,U,GAAkBC,GAAG,CAArB,U;SACA,S,GAAiBA,GAAG,CAApB,S;SACA,I,GAAYA,GAAG,CAAf,I;;;;;;;;AAOFC,EAAAA,KAAK,CAAA,GAAA,EAAM;QACLC,IAAI,GAAR,I;WACO;QACHC,MAAM,CAAR,Q,IAAqB;YACfC,KAAK,GAAT,a;YACIC,QAAQ,GAAZ,I;YACIC,aAAa,GAAjB,I;YACIC,SAAS,GAAb,I;;aAEK,IAAIC,CAAC,GAAV,C,EAAgBA,CAAC,GAAGC,GAAG,CAAvB,M,EAAgCD,CAAhC,E,EAAqC;cAC/BE,CAAC,GAAGD,GAAG,CAAX,CAAW,C;AAEXF,UAAAA,SAAS,GAATA,KAAAA;AACAH,UAAAA,KAAK,GAAGF,IAAI,CAAJA,UAAAA,CAAAA,KAAAA,EAARE,CAAQF,CAARE;;cAEIA,KAAK,KAAT,U,EAA0B;;gBAEpBC,QAAQ,IAARA,IAAAA,IAAoBC,aAAa,IAAjCD,IAAAA,IAA6CC,aAAa,IAA9D,Q,EAA4E;oBACpE,CAAA,QAAA,EAAA,aAAA,EAA0BJ,IAAI,CAAJA,IAAAA,CAAhC,SAAgCA,CAA1B,C;AAHgB,aAAA,CAAA;;;AAOxBE,YAAAA,KAAK,GAAGF,IAAI,CAAJA,UAAAA,CAAAA,aAAAA,EAARE,CAAQF,CAARE;AACAC,YAAAA,QAAQ,GAARA,IAAAA;AAdiC,WAAA,CAAA;;;cAkB/BD,KAAK,KAALA,UAAAA,IAAwBC,QAAQ,IAApC,I,EAA8C;AAC5CA,YAAAA,QAAQ,GAARA,CAAAA;AAnBiC,WAAA,CAAA;;;cAuB/BH,IAAI,CAAJA,SAAAA,CAAJ,KAAIA,C,EAAuB;AACzBI,YAAAA,aAAa,GAAbA,CAAAA;AAxBiC,WAAA,CAAA;;;cA4B/BF,KAAK,KAAT,U,EAA0B;AACxBA,YAAAA,KAAK,GAALA,aAAAA;;AAnCe,SAAA,CAAA;;;YAwCfC,QAAQ,IAARA,IAAAA,IAAoBC,aAAa,IAAjCD,IAAAA,IAA6CC,aAAa,IAA9D,Q,EAA4E;gBACpE,CAAA,QAAA,EAAA,aAAA,EAA0BJ,IAAI,CAAJA,IAAAA,CAAhC,KAAgCA,CAA1B,C;;;;AA1CL,K;;;;;;;;;AAqDTS,EAAAA,KAAK,CAAA,GAAA,EAAA,OAAA,EAAe;SACb,IAAI,CAAA,KAAA,EAAA,GAAA,EAAT,IAAS,C,IAAsB,KAAA,KAAA,CAA/B,GAA+B,C,EAAiB;WACzC,IAAL,G,IAAA,I,EAAsB;YAChB,OAAOC,OAAO,CAAd,GAAc,CAAd,KAAJ,U,EAAwC;AACtCA,UAAAA,OAAO,CAAPA,GAAO,CAAPA,CAAAA,KAAAA,EAAAA,GAAAA,EAAyBH,GAAG,CAAHA,KAAAA,CAAAA,KAAAA,EAAiBI,GAAG,GAA7CD,CAAyBH,CAAzBG;;;;;;AAtEwB","sourcesContent":["const INITIAL_STATE = 1;\nconst FAIL_STATE = 0;\n\n/**\n * A StateMachine represents a deterministic finite automaton.\n * It can perform matches over a sequence of values, similar to a regular expression.\n */\nexport default class StateMachine {\n  constructor(dfa) {\n    this.stateTable = dfa.stateTable;\n    this.accepting = dfa.accepting;\n    this.tags = dfa.tags;\n  }\n\n  /**\n   * Returns an iterable object that yields pattern matches over the input sequence.\n   * Matches are of the form [startIndex, endIndex, tags].\n   */\n  match(str) {\n    let self = this;\n    return {\n      *[Symbol.iterator]() {\n        let state = INITIAL_STATE;\n        let startRun = null;\n        let lastAccepting = null;\n        let lastState = null;\n\n        for (let p = 0; p < str.length; p++) {\n          let c = str[p];\n\n          lastState = state;\n          state = self.stateTable[state][c];\n\n          if (state === FAIL_STATE) {\n            // yield the last match if any\n            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n              yield [startRun, lastAccepting, self.tags[lastState]];\n            }\n\n            // reset the state as if we started over from the initial state\n            state = self.stateTable[INITIAL_STATE][c];\n            startRun = null;\n          }\n\n          // start a run if not in the failure state\n          if (state !== FAIL_STATE && startRun == null) {\n            startRun = p;\n          }\n\n          // if accepting, mark the potential match end\n          if (self.accepting[state]) {\n            lastAccepting = p;\n          }\n\n          // reset the state to the initial state if we get into the failure state\n          if (state === FAIL_STATE) {\n            state = INITIAL_STATE;\n          }\n        }\n\n        // yield the last match if any\n        if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n          yield [startRun, lastAccepting, self.tags[state]];\n        }\n      }\n    };\n  }\n\n  /**\n   * For each match over the input sequence, action functions matching\n   * the tag definitions in the input pattern are called with the startIndex,\n   * endIndex, and sub-match sequence.\n   */\n  apply(str, actions) {\n    for (let [start, end, tags] of this.match(str)) {\n      for (let tag of tags) {\n        if (typeof actions[tag] === 'function') {\n          actions[tag](start, end, str.slice(start, end + 1));\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}