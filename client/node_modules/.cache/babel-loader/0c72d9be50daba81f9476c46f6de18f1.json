{"ast":null,"code":"\"use strict\";\n\nconst parse5 = require(\"parse5\");\n\nconst sax = require(\"sax\");\n\nconst attributes = require(\"../living/attributes\");\n\nconst DocumentType = require(\"../living/generated/DocumentType\");\n\nconst JSDOMParse5Adapter = require(\"./parse5-adapter-parsing\");\n\nconst {\n  HTML_NS\n} = require(\"../living/helpers/namespaces\"); // Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237\n\n\nconst OpenElementStack = require(\"parse5/lib/parser/open_element_stack\");\n\nconst originalPop = OpenElementStack.prototype.pop;\n\nOpenElementStack.prototype.pop = function (...args) {\n  const before = this.items[this.stackTop];\n  originalPop.apply(this, args);\n\n  if (before._poppedOffStackOfOpenElements) {\n    before._poppedOffStackOfOpenElements();\n  }\n};\n\nconst originalPush = OpenElementStack.prototype.push;\n\nOpenElementStack.prototype.push = function (...args) {\n  originalPush.apply(this, args);\n  const after = this.items[this.stackTop];\n\n  if (after._pushedOnStackOfOpenElements) {\n    after._pushedOnStackOfOpenElements();\n  }\n};\n\nmodule.exports = class HTMLToDOM {\n  constructor(parsingMode) {\n    this.parser = parsingMode === \"xml\" ? sax : parse5;\n  }\n\n  appendToNode(html, node) {\n    html = String(html);\n    return this._doParse(html, true, node);\n  }\n\n  appendToDocument(html, documentImpl) {\n    html = String(html);\n    return this._doParse(html, false, documentImpl, documentImpl._parseOptions);\n  }\n\n  _doParse(...args) {\n    return this.parser === parse5 ? this._parseWithParse5(...args) : this._parseWithSax(...args);\n  }\n\n  _parseWithParse5(html, isFragment, contextNode, options = {}) {\n    const adapter = new JSDOMParse5Adapter(contextNode._ownerDocument || contextNode);\n    options.treeAdapter = adapter;\n\n    if (isFragment) {\n      const fragment = this.parser.parseFragment(contextNode, html, options);\n\n      if (contextNode._templateContents) {\n        contextNode._templateContents.appendChild(fragment);\n      } else {\n        contextNode.appendChild(fragment);\n      }\n    } else {\n      this.parser.parse(html, options);\n    }\n\n    return contextNode;\n  }\n\n  _parseWithSax(html, isFragment, contextNode) {\n    const SaxParser = this.parser.parser;\n    const parser = new SaxParser(\n    /* strict = */\n    true, {\n      xmlns: true,\n      strictEntities: true\n    });\n    parser.noscript = false;\n    parser.looseCase = \"toString\";\n    const openStack = [contextNode];\n\n    parser.ontext = text => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"text\",\n        data: text\n      });\n    };\n\n    parser.oncdata = cdata => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"cdata\",\n        data: cdata\n      });\n    };\n\n    parser.onopentag = arg => {\n      const attrs = Object.keys(arg.attributes).map(key => {\n        const rawAttribute = arg.attributes[key];\n        let {\n          prefix\n        } = rawAttribute;\n        let localName = rawAttribute.local;\n\n        if (prefix === \"xmlns\" && localName === \"\") {\n          // intended weirdness in node-sax, see https://github.com/isaacs/sax-js/issues/165\n          localName = prefix;\n          prefix = null;\n        }\n\n        if (prefix === \"\") {\n          prefix = null;\n        }\n\n        const namespace = rawAttribute.uri === \"\" ? null : rawAttribute.uri;\n        return {\n          name: rawAttribute.name,\n          value: rawAttribute.value,\n          prefix,\n          localName,\n          namespace\n        };\n      });\n      const tag = {\n        type: \"tag\",\n        name: arg.local,\n        prefix: arg.prefix,\n        namespace: arg.uri,\n        attributes: attrs\n      };\n\n      if (arg.local === \"script\" && arg.uri === HTML_NS) {\n        openStack.push(tag);\n      } else {\n        const elem = setChildForSax(openStack[openStack.length - 1], tag);\n        openStack.push(elem);\n      }\n    };\n\n    parser.onclosetag = () => {\n      const elem = openStack.pop();\n\n      if (elem.constructor.name === \"Object\") {\n        // we have an empty script tag\n        setChildForSax(openStack[openStack.length - 1], elem);\n      }\n    };\n\n    parser.onscript = scriptText => {\n      const tag = openStack.pop();\n      tag.children = [{\n        type: \"text\",\n        data: scriptText\n      }];\n      const elem = setChildForSax(openStack[openStack.length - 1], tag);\n      openStack.push(elem);\n    };\n\n    parser.oncomment = comment => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"comment\",\n        data: comment\n      });\n    };\n\n    parser.onprocessinginstruction = pi => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"?\" + pi.name,\n        data: \"?\" + pi.name + \" \" + pi.body + \"?\"\n      });\n    };\n\n    parser.ondoctype = dt => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"!doctype\",\n        data: \"!doctype \" + dt\n      });\n      const entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n      let result;\n\n      while (result = entityMatcher.exec(dt)) {\n        const [, name, value] = result;\n\n        if (!(name in parser.ENTITIES)) {\n          parser.ENTITIES[name] = value;\n        }\n      }\n    };\n\n    parser.onerror = err => {\n      throw err;\n    };\n\n    parser.write(html).close();\n  }\n\n};\n\nfunction setChildForSax(parentImpl, node) {\n  const currentDocument = parentImpl && parentImpl._ownerDocument || parentImpl;\n  let newNode;\n  let isTemplateContents = false;\n\n  switch (node.type) {\n    case \"tag\":\n    case \"script\":\n    case \"style\":\n      newNode = currentDocument._createElementWithCorrectElementInterface(node.name, node.namespace);\n      newNode._prefix = node.prefix || null;\n      newNode._namespaceURI = node.namespace || null;\n      break;\n\n    case \"root\":\n      // If we are in <template> then add all children to the parent's _templateContents; skip this virtual root node.\n      if (parentImpl.tagName === \"TEMPLATE\" && parentImpl._namespaceURI === HTML_NS) {\n        newNode = parentImpl._templateContents;\n        isTemplateContents = true;\n      }\n\n      break;\n\n    case \"text\":\n      // HTML entities should already be decoded by the parser, so no need to decode them\n      newNode = currentDocument.createTextNode(node.data);\n      break;\n\n    case \"cdata\":\n      newNode = currentDocument.createCDATASection(node.data);\n      break;\n\n    case \"comment\":\n      newNode = currentDocument.createComment(node.data);\n      break;\n\n    case \"directive\":\n      if (node.name[0] === \"?\" && node.name.toLowerCase() !== \"?xml\") {\n        const data = node.data.slice(node.name.length + 1, -1);\n        newNode = currentDocument.createProcessingInstruction(node.name.substring(1), data);\n      } else if (node.name.toLowerCase() === \"!doctype\") {\n        newNode = parseDocType(currentDocument, \"<\" + node.data + \">\");\n      }\n\n      break;\n  }\n\n  if (!newNode) {\n    return null;\n  }\n\n  if (node.attributes) {\n    for (const a of node.attributes) {\n      attributes.setAttributeValue(newNode, a.localName, a.value, a.prefix, a.namespace);\n    }\n  }\n\n  if (node.children) {\n    for (let c = 0; c < node.children.length; c++) {\n      setChildForSax(newNode, node.children[c]);\n    }\n  }\n\n  if (!isTemplateContents) {\n    if (parentImpl._templateContents) {\n      // Setting innerHTML on a <template>\n      parentImpl._templateContents.appendChild(newNode);\n    } else {\n      parentImpl.appendChild(newNode);\n    }\n  }\n\n  return newNode;\n}\n\nconst HTML5_DOCTYPE = /<!doctype html>/i;\nconst PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nconst SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\n\nfunction parseDocType(doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n  }\n\n  const publicPieces = PUBLIC_DOCTYPE.exec(html);\n\n  if (publicPieces) {\n    return createDocumentTypeInternal(doc, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  const systemPieces = SYSTEM_DOCTYPE.exec(html);\n\n  if (systemPieces) {\n    return createDocumentTypeInternal(doc, systemPieces[1], \"\", systemPieces[2]);\n  } // Shouldn't get here (the parser shouldn't let us know about invalid doctypes), but our logic likely isn't\n  // real-world perfect, so let's fallback.\n\n\n  return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n}\n\nfunction createDocumentTypeInternal(ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl([], {\n    ownerDocument,\n    name,\n    publicId,\n    systemId\n  });\n}","map":{"version":3,"sources":["/Users/krispol/Desktop/invoice/invoice-with-session/client/node_modules/jsdom/lib/jsdom/browser/htmltodom.js"],"names":["parse5","require","sax","attributes","DocumentType","JSDOMParse5Adapter","HTML_NS","OpenElementStack","originalPop","prototype","pop","args","before","items","stackTop","apply","_poppedOffStackOfOpenElements","originalPush","push","after","_pushedOnStackOfOpenElements","module","exports","HTMLToDOM","constructor","parsingMode","parser","appendToNode","html","node","String","_doParse","appendToDocument","documentImpl","_parseOptions","_parseWithParse5","_parseWithSax","isFragment","contextNode","options","adapter","_ownerDocument","treeAdapter","fragment","parseFragment","_templateContents","appendChild","parse","SaxParser","xmlns","strictEntities","noscript","looseCase","openStack","ontext","text","setChildForSax","length","type","data","oncdata","cdata","onopentag","arg","attrs","Object","keys","map","key","rawAttribute","prefix","localName","local","namespace","uri","name","value","tag","elem","onclosetag","onscript","scriptText","children","oncomment","comment","onprocessinginstruction","pi","body","ondoctype","dt","entityMatcher","result","exec","ENTITIES","onerror","err","write","close","parentImpl","currentDocument","newNode","isTemplateContents","_createElementWithCorrectElementInterface","_prefix","_namespaceURI","tagName","createTextNode","createCDATASection","createComment","toLowerCase","slice","createProcessingInstruction","substring","parseDocType","a","setAttributeValue","c","HTML5_DOCTYPE","PUBLIC_DOCTYPE","SYSTEM_DOCTYPE","doc","test","createDocumentTypeInternal","publicPieces","systemPieces","ownerDocument","publicId","systemId","createImpl"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst parse5 = require(\"parse5\");\nconst sax = require(\"sax\");\nconst attributes = require(\"../living/attributes\");\nconst DocumentType = require(\"../living/generated/DocumentType\");\nconst JSDOMParse5Adapter = require(\"./parse5-adapter-parsing\");\nconst { HTML_NS } = require(\"../living/helpers/namespaces\");\n\n// Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237\nconst OpenElementStack = require(\"parse5/lib/parser/open_element_stack\");\nconst originalPop = OpenElementStack.prototype.pop;\nOpenElementStack.prototype.pop = function (...args) {\n  const before = this.items[this.stackTop];\n  originalPop.apply(this, args);\n  if (before._poppedOffStackOfOpenElements) {\n    before._poppedOffStackOfOpenElements();\n  }\n};\n\nconst originalPush = OpenElementStack.prototype.push;\nOpenElementStack.prototype.push = function (...args) {\n  originalPush.apply(this, args);\n  const after = this.items[this.stackTop];\n  if (after._pushedOnStackOfOpenElements) {\n    after._pushedOnStackOfOpenElements();\n  }\n};\n\nmodule.exports = class HTMLToDOM {\n  constructor(parsingMode) {\n    this.parser = parsingMode === \"xml\" ? sax : parse5;\n  }\n\n  appendToNode(html, node) {\n    html = String(html);\n\n    return this._doParse(html, true, node);\n  }\n\n  appendToDocument(html, documentImpl) {\n    html = String(html);\n\n    return this._doParse(html, false, documentImpl, documentImpl._parseOptions);\n  }\n\n  _doParse(...args) {\n    return this.parser === parse5 ? this._parseWithParse5(...args) : this._parseWithSax(...args);\n  }\n\n  _parseWithParse5(html, isFragment, contextNode, options = {}) {\n    const adapter = new JSDOMParse5Adapter(contextNode._ownerDocument || contextNode);\n    options.treeAdapter = adapter;\n\n    if (isFragment) {\n      const fragment = this.parser.parseFragment(contextNode, html, options);\n\n      if (contextNode._templateContents) {\n        contextNode._templateContents.appendChild(fragment);\n      } else {\n        contextNode.appendChild(fragment);\n      }\n    } else {\n      this.parser.parse(html, options);\n    }\n\n    return contextNode;\n  }\n\n  _parseWithSax(html, isFragment, contextNode) {\n    const SaxParser = this.parser.parser;\n    const parser = new SaxParser(/* strict = */true, { xmlns: true, strictEntities: true });\n    parser.noscript = false;\n    parser.looseCase = \"toString\";\n    const openStack = [contextNode];\n    parser.ontext = text => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"text\",\n        data: text\n      });\n    };\n    parser.oncdata = cdata => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"cdata\",\n        data: cdata\n      });\n    };\n    parser.onopentag = arg => {\n      const attrs = Object.keys(arg.attributes).map(key => {\n        const rawAttribute = arg.attributes[key];\n\n        let { prefix } = rawAttribute;\n        let localName = rawAttribute.local;\n        if (prefix === \"xmlns\" && localName === \"\") {\n          // intended weirdness in node-sax, see https://github.com/isaacs/sax-js/issues/165\n          localName = prefix;\n          prefix = null;\n        }\n\n        if (prefix === \"\") {\n          prefix = null;\n        }\n\n        const namespace = rawAttribute.uri === \"\" ? null : rawAttribute.uri;\n\n        return { name: rawAttribute.name, value: rawAttribute.value, prefix, localName, namespace };\n      });\n      const tag = {\n        type: \"tag\",\n        name: arg.local,\n        prefix: arg.prefix,\n        namespace: arg.uri,\n        attributes: attrs\n      };\n\n      if (arg.local === \"script\" && arg.uri === HTML_NS) {\n        openStack.push(tag);\n      } else {\n        const elem = setChildForSax(openStack[openStack.length - 1], tag);\n        openStack.push(elem);\n      }\n    };\n    parser.onclosetag = () => {\n      const elem = openStack.pop();\n      if (elem.constructor.name === \"Object\") { // we have an empty script tag\n        setChildForSax(openStack[openStack.length - 1], elem);\n      }\n    };\n    parser.onscript = scriptText => {\n      const tag = openStack.pop();\n      tag.children = [{ type: \"text\", data: scriptText }];\n      const elem = setChildForSax(openStack[openStack.length - 1], tag);\n      openStack.push(elem);\n    };\n    parser.oncomment = comment => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"comment\",\n        data: comment\n      });\n    };\n    parser.onprocessinginstruction = pi => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"?\" + pi.name,\n        data: \"?\" + pi.name + \" \" + pi.body + \"?\"\n      });\n    };\n    parser.ondoctype = dt => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"!doctype\",\n        data: \"!doctype \" + dt\n      });\n\n      const entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n      let result;\n      while ((result = entityMatcher.exec(dt))) {\n        const [, name, value] = result;\n        if (!(name in parser.ENTITIES)) {\n          parser.ENTITIES[name] = value;\n        }\n      }\n    };\n\n    parser.onerror = err => {\n      throw err;\n    };\n    parser.write(html).close();\n  }\n};\n\nfunction setChildForSax(parentImpl, node) {\n  const currentDocument = (parentImpl && parentImpl._ownerDocument) || parentImpl;\n\n  let newNode;\n  let isTemplateContents = false;\n  switch (node.type) {\n    case \"tag\":\n    case \"script\":\n    case \"style\":\n      newNode = currentDocument._createElementWithCorrectElementInterface(node.name, node.namespace);\n      newNode._prefix = node.prefix || null;\n      newNode._namespaceURI = node.namespace || null;\n      break;\n\n    case \"root\":\n      // If we are in <template> then add all children to the parent's _templateContents; skip this virtual root node.\n      if (parentImpl.tagName === \"TEMPLATE\" && parentImpl._namespaceURI === HTML_NS) {\n        newNode = parentImpl._templateContents;\n        isTemplateContents = true;\n      }\n      break;\n\n    case \"text\":\n      // HTML entities should already be decoded by the parser, so no need to decode them\n      newNode = currentDocument.createTextNode(node.data);\n      break;\n\n    case \"cdata\":\n      newNode = currentDocument.createCDATASection(node.data);\n      break;\n\n    case \"comment\":\n      newNode = currentDocument.createComment(node.data);\n      break;\n\n    case \"directive\":\n      if (node.name[0] === \"?\" && node.name.toLowerCase() !== \"?xml\") {\n        const data = node.data.slice(node.name.length + 1, -1);\n        newNode = currentDocument.createProcessingInstruction(node.name.substring(1), data);\n      } else if (node.name.toLowerCase() === \"!doctype\") {\n        newNode = parseDocType(currentDocument, \"<\" + node.data + \">\");\n      }\n      break;\n  }\n\n  if (!newNode) {\n    return null;\n  }\n\n  if (node.attributes) {\n    for (const a of node.attributes) {\n      attributes.setAttributeValue(newNode, a.localName, a.value, a.prefix, a.namespace);\n    }\n  }\n\n  if (node.children) {\n    for (let c = 0; c < node.children.length; c++) {\n      setChildForSax(newNode, node.children[c]);\n    }\n  }\n\n  if (!isTemplateContents) {\n    if (parentImpl._templateContents) {\n      // Setting innerHTML on a <template>\n      parentImpl._templateContents.appendChild(newNode);\n    } else {\n      parentImpl.appendChild(newNode);\n    }\n  }\n\n  return newNode;\n}\n\nconst HTML5_DOCTYPE = /<!doctype html>/i;\nconst PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nconst SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\n\nfunction parseDocType(doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n  }\n\n  const publicPieces = PUBLIC_DOCTYPE.exec(html);\n  if (publicPieces) {\n    return createDocumentTypeInternal(doc, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  const systemPieces = SYSTEM_DOCTYPE.exec(html);\n  if (systemPieces) {\n    return createDocumentTypeInternal(doc, systemPieces[1], \"\", systemPieces[2]);\n  }\n\n  // Shouldn't get here (the parser shouldn't let us know about invalid doctypes), but our logic likely isn't\n  // real-world perfect, so let's fallback.\n  return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n}\n\nfunction createDocumentTypeInternal(ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl([], { ownerDocument, name, publicId, systemId });\n}\n"]},"metadata":{},"sourceType":"script"}